<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Super Maze</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
        }

        #game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #maze-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100vw - 320px);
            height: 100vh;
            background: #181818;
            display: block;
            margin: 0;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #2a2a2a;
            padding: 24px 16px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            border-left: 2px solid #444;
            z-index: 10;
        }

        #sidebar h2 {
            margin-top: 0;
            font-size: 1.4em;
            color: #ffd700;
        }

        .score,
        .steps,
        .timer,
        .inventory {
            margin-bottom: 18px;
            font-size: 1.1em;
        }

        #help-btn {
            background: #444;
            color: #ffd700;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            cursor: pointer;
            margin-bottom: 16px;
        }

        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #help-content {
            background: #333;
            padding: 32px;
            border-radius: 12px;
            max-width: 480px;
            box-shadow: 0 0 24px #000;
        }

        #close-help {
            margin-top: 24px;
            background: #444;
            color: #ffd700;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }

        #map-size-select {
            margin-bottom: 18px;
            font-size: 1.1em;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: #ffd700;
        }

        #start-btn {
            background: #ffd700;
            color: #222;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            font-size: 1.1em;
            cursor: pointer;
            margin-bottom: 24px;
        }

        #endgame-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        #endgame-modal>div {
            background: #333;
            color: #ffd700;
            padding: 32px;
            border-radius: 12px;
            max-width: 400px;
            box-shadow: 0 0 24px #000;
            text-align: center;
        }

        #endgame-modal #close-endgame {
            margin-top: 24px;
            background: #444;
            color: #ffd700;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }

        .home-link {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            text-decoration: none;
            color: #fff;
            font-size: 1.1em;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="maze-canvas"></canvas>
        <div id="sidebar">
            <a href="../index.html" title="Back to Home" class="home-link">
                <svg width="28" height="28" viewBox="0 0 24 24">
                    <path d="M15 18l-6-6 6-6" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Home</span>
            </a>
            <h2>Super Maze</h2>
            <label for="map-size-select">Map Size:</label>
            <select id="map-size-select">
                <option value="11">11 x 11</option>
                <option value="25" selected>25 x 25</option>
                <option value="51">51 x 51</option>
                <option value="101">101 x 101</option>
            </select>
            <button id="start-btn">Start Game</button>
            <div class="score">Score: <span id="score">0</span></div>
            <div class="steps">Steps: <span id="steps">0</span></div>
            <div class="timer">Time: <span id="timer">0</span>s</div>
            <div class="inventory">Inventory: <span id="inventory">None</span></div>
            <button id="help-btn">?</button>
        </div>
    </div>
    <div id="help-modal">
        <div id="help-content">
            <h3>How to Play</h3>
            <ul>
                <li>Use arrow keys or WASD to move.</li>
                <li>Find the exit in the maze.</li>
                <li>Collect items and power-ups as you explore.</li>
                <li>Map view is fixed until you find location power-ups.</li>
                <li>Reveal the map with special power-ups.</li>
            </ul>
            <button id="close-help">Close</button>
        </div>
    </div>
    <div id="endgame-modal">
        <div>
            <h3 id="endgame-title"></h3>
            <div id="endgame-details"></div>
            <button id="close-endgame">Close</button>
        </div>
    </div>
    <script>
        /*
            TODO:
            - place power-ups more evenly throughout the maze
            - refactor powerUp.isActive flags
            - refactor the exit as special power-up
        */

        // --- Game Constants ---
        const TILE_SIZE = 32;
        const VISIBLE_SIZE = 9; // 9x9 visible window
        // Map size is now selected directly as a number
        // --- Game State ---
        let mapSize = 25; // Default demo size
        let maze = [];
        let player = { x: 1, y: 1 };
        let exit = { x: 0, y: 0 };
        let score = 0;
        let steps = 0;
        let timer = 0;
        let inventory = [];
        let gameStarted = false;
        let revealMap = false;
        let followPlayer = false;
        let timerInterval = null;
        let powerUps = [
            {
                type: 'fog',
                description: 'Fog of War: Hides unexplored areas of the maze',
                color: '#a020f0',
                probability: 0.3,
                // isActive: false // TODO: not used yet
            },
            {
                type: 'markVisited',
                description: 'Mark Visited: Marks all visited tiles on the map',
                color: '#ff9800',
                probability: 0.5,
            },
            {
                type: 'showPath',
                description: 'Show Path: Reveals the optimal path to the exit',
                color: '#00ffea',
                probability: 0.1,
            },
            {
                type: 'revealMap',
                description: 'Reveal Map: Shows the entire maze layout until moved',
                color: '#00ff00',
                probability: 0.1,
            },
            {
                type: 'showFullMap',
                description: 'Show Full Map: Permanently reveals the entire maze',
                color: '#0000ff',
                probability: 0.1,
            },
            {
                type: 'followLocation',
                description: 'Follow Location: Shows full map, but only viewport is visible, rest is dark',
                color: '#ff00ff',
                probability: 0.1,
            }
        ]
        let placedPowerUps = [];
        let powerUpFogActive = false;
        let powerUpMarkVisitedActive = false;
        let showFullMapActive = false;
        let followLocationActive = false;
        // --- DOM Elements ---
        const canvas = document.getElementById('maze-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const stepsEl = document.getElementById('steps');
        const timerEl = document.getElementById('timer');
        const inventoryEl = document.getElementById('inventory');
        const helpBtn = document.getElementById('help-btn');
        const helpModal = document.getElementById('help-modal');
        const closeHelpBtn = document.getElementById('close-help');
        const mapSizeSelect = document.getElementById('map-size-select');
        const startBtn = document.getElementById('start-btn');

        // --- Maze Generation (Recursive Backtracker) ---
        function generateMaze(size) {
            // Initialize maze with walls
            maze = Array(size).fill().map(() =>
                Array(size).fill().map(() => ({ wall: true, visited: false, explored: false }))
            );
            let stack = [];
            let startX = 1, startY = 1;
            stack.push([startX, startY]);
            maze[startY][startX] = { wall: false, visited: true, explored: true };
            while (stack.length > 0) {
                let [x, y] = stack[stack.length - 1];
                let dirs = [[0, -2], [0, 2], [-2, 0], [2, 0]];
                dirs = dirs.sort(() => Math.random() - 0.5);
                let carved = false;
                for (let [dx, dy] of dirs) {
                    let nx = x + dx, ny = y + dy;
                    if (nx > 0 && ny > 0 && nx < size && ny < size && maze[ny][nx].wall === true) {
                        maze[y + dy / 2][x + dx / 2].wall = false;
                        maze[ny][nx].wall = false;
                        stack.push([nx, ny]);
                        carved = true;
                        break;
                    }
                }
                if (!carved) {
                    stack.pop();
                }
            }
            // Place exit
            exit = { x: size - 2, y: size - 2 };
        }

        function placePowerUps() {
            placedPowerUps = [];
            let deadEnds = findDeadEnds();
            // If not enough dead-ends, regenerate maze
            let tries = 0;
            while (deadEnds.length < powerUps.length && tries < 10) {
                generateMaze(mapSize);
                deadEnds = findDeadEnds();
                tries++;
            }
            // Calculate number of power-ups based on maze size
            let ratio = 1/60; // 1 power-up per 60 cells
            let minPowerUps = powerUps.length;
            let maxPowerUps = Math.max(minPowerUps, Math.floor(mapSize * mapSize / 8));
            let count = Math.max(minPowerUps, Math.min(deadEnds.length, Math.round(mapSize * mapSize * ratio)));
            count = Math.min(count, maxPowerUps);
            // Ensure every power-up is included at least once
            let chosen = [];
            // Place one of each power-up type
            for (let i = 0; i < powerUps.length && deadEnds.length > 0; i++) {
                let idx = randInt(0, deadEnds.length - 1);
                let pos = deadEnds.splice(idx, 1)[0];
                chosen.push({ powerUp: powerUps[i], x: pos.x, y: pos.y });
            }
            // Fill the rest randomly
            while (chosen.length < count && deadEnds.length > 0) {
                let idx = randInt(0, deadEnds.length - 1);
                let pos = deadEnds.splice(idx, 1)[0];
                const randomPowerUp = getRandomPowerUp();
                chosen.push({ powerUp: randomPowerUp, x: pos.x, y: pos.y });
            }
            placedPowerUps = chosen;
        }

        // Get a random power-up by wieghted probability
        function getRandomPowerUp() {
            let totalProb = powerUps.reduce((sum, p) => sum + p.probability, 0);
            let rand = Math.random() * totalProb;
            for (const p of powerUps) {
                if (rand < p.probability) {
                    return p;
                }
                rand -= p.probability;
            }
            return null;
        }

        // --- Rendering ---
        function resizeCanvas() {
            // Set both CSS and element attributes for canvas size
            const w = window.innerWidth - 320;
            const h = window.innerHeight;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            canvas.width = w;
            canvas.height = h;
        }

        function renderMaze({ mode = 'normal' } = {}) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let tileSize, offsetX, offsetY, startX, startY, endX, endY;
            let px = player.x, py = player.y;
            let half = Math.floor(VISIBLE_SIZE / 2);
            let vx = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, px - half));
            let vy = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, py - half));
            if (mode === 'full' || mode === 'followLocation') {
                tileSize = Math.min((canvas.width - 10) / mapSize, (canvas.height - 10) / mapSize);
                offsetX = (canvas.width - tileSize * mapSize) / 2;
                offsetY = (canvas.height - tileSize * mapSize) / 2;
                startX = 0; startY = 0; endX = mapSize; endY = mapSize;
            } else {
                tileSize = TILE_SIZE;
                vx = px - half;
                vy = py - half;
                if (followPlayer || revealMap || powerUpFogActive) {
                    vx = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, px - half));
                    vy = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, py - half));
                } else {
                    vx = Math.floor((mapSize - VISIBLE_SIZE) / 2);
                    vy = Math.floor((mapSize - VISIBLE_SIZE) / 2);
                }
                offsetX = (canvas.width - VISIBLE_SIZE * tileSize) / 2;
                offsetY = (canvas.height - VISIBLE_SIZE * tileSize) / 2;
                startX = vx; startY = vy; endX = vx + VISIBLE_SIZE; endY = vy + VISIBLE_SIZE;
            }
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    let tile = maze[y]?.[x] ?? { wall: true };
                    let sx = offsetX + (x - startX) * tileSize;
                    let sy = offsetY + (y - startY) * tileSize;
                    let inViewport = true;
                    if (mode === 'followLocation') {
                        inViewport = x >= vx && x < vx + VISIBLE_SIZE && y >= vy && y < vy + VISIBLE_SIZE;
                        if (!inViewport) {
                            ctx.fillStyle = '#111';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                            continue;
                        }
                    }
                    // Fog of war logic (only for viewport)
                    if (mode === 'normal' && powerUpFogActive && !tile.explored) {
                        ctx.fillStyle = '#111';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                        continue;
                    }
                    if (mode === 'normal' && !powerUpFogActive && !revealMap && !isTileVisible(x, y)) {
                        ctx.fillStyle = '#111';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                        continue;
                    }
                    if (exit && x === exit.x && y === exit.y) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                    } else if (tile.wall === true) {
                        ctx.fillStyle = '#444';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                    } else if (powerUpMarkVisitedActive && tile.visited) {
                        ctx.fillStyle = '#b7e4c7';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                    } else if (tile.visited && mode === 'full') {
                        ctx.fillStyle = '#b7e4c7';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                    } else if (tile.explored && mode === 'full') {
                        ctx.fillStyle = '#8ecae6';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                    } else if (tile.wall === false) {
                        ctx.fillStyle = '#eee';
                        ctx.fillRect(sx, sy, tileSize, tileSize);
                    }
                    // Draw power-ups
                    for (const p of placedPowerUps) {
                        if (p.x === x && p.y === y) {
                            ctx.fillStyle = p.powerUp.color;
                            ctx.beginPath();
                            ctx.arc(sx + tileSize / 2, sy + tileSize / 2, tileSize / 3, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                    // Draw guide path if active
                    if (guideActive && guidePath) {
                        for (let i = 0; i < guideStep; i++) {
                            let gp = guidePath[i];
                            if (mode === 'full') {
                                let gx = gp.x - startX, gy = gp.y - startY;
                                let size = mapSize;
                                if (gx >= 0 && gx < size && gy >= 0 && gy < size) {
                                    let sx2 = offsetX + gx * tileSize;
                                    let sy2 = offsetY + gy * tileSize;
                                    ctx.fillStyle = '#00ffea';
                                    ctx.fillRect(sx2 + tileSize / 4, sy2 + tileSize / 4, tileSize / 2, tileSize / 2);
                                }
                            } else if (mode === 'followLocation') {
                                if (gp.x === x && gp.y === y) {
                                    ctx.fillStyle = '#00ffea';
                                    ctx.fillRect(sx + tileSize / 4, sy + tileSize / 4, tileSize / 2, tileSize / 2);
                                }
                            } else {
                                let gx = gp.x - startX, gy = gp.y - startY;
                                let size = VISIBLE_SIZE;
                                if (gx >= 0 && gx < size && gy >= 0 && gy < size) {
                                    let sx2 = offsetX + gx * tileSize;
                                    let sy2 = offsetY + gy * tileSize;
                                    ctx.fillStyle = '#00ffea';
                                    ctx.fillRect(sx2 + tileSize / 4, sy2 + tileSize / 4, tileSize / 2, tileSize / 2);
                                }
                            }
                        }
                    }
                    // Player
                    if (x === player.x && y === player.y) {
                        ctx.fillStyle = '#00f';
                        ctx.beginPath();
                        ctx.arc(sx + tileSize / 2, sy + tileSize / 2, tileSize / 2.2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }
        }

        function render() {
            if (showFullMapActive) {
                renderMaze({ mode: 'full' });
            } else if (followLocationActive) {
                renderMaze({ mode: 'followLocation' });
            } else {
                renderMaze({ mode: 'normal' });
            }
        }

        function renderFullMaze() {
            renderMaze({ mode: 'full' });
        }

        // --- Fog of War ---
        let visibleTiles = new Set();

        function isTileVisible(x, y) {
            return visibleTiles.has(`${x},${y}`);
        }

        function updateVisibility() {
            let radius = 4;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    let nx = player.x + dx, ny = player.y + dy;
                    if (nx >= 0 && ny >= 0 && nx < mapSize && ny < mapSize) {
                        visibleTiles.add(`${nx},${ny}`);
                        // Only mark as explored in movePlayer
                    }
                }
            }
        }

        // --- Game Logic ---
        function startGame() {
            mapSize = parseInt(mapSizeSelect.value);
            // Show loading indicator for large mazes
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffd700';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Generating maze...', canvas.width / 2, canvas.height / 2);
            setTimeout(() => {
                let tries = 0;
                do {
                    generateMaze(mapSize);
                    // Find a valid starting position (first open path near top-left)
                    let found = false;
                    for (let y = 1; y < Math.min(10, mapSize) && !found; y++) {
                        for (let x = 1; x < Math.min(10, mapSize) && !found; x++) {
                            if (maze[y][x].wall === false) {
                                player = { x, y };
                                found = true;
                            }
                        }
                    }
                    if (!found) player = { x: 1, y: 1 };
                    exit = { x: mapSize - 2, y: mapSize - 2 };
                    tries++;
                } while (!isMazeFullyReachable() && tries < 20);
                score = 0;
                steps = 0;
                timer = 0;
                inventory = [];
                visibleTiles = new Set();
                // Always show full maze and follow player
                revealMap = true;
                followPlayer = true;
                gameStarted = true;
                // Mark starting cell as visited and explored
                maze[player.y][player.x].visited = true;
                if (!maze[player.y][player.x].explored) {
                    maze[player.y][player.x].explored = true;
                    score = 1;
                    scoreEl.textContent = score;
                }
                placePowerUps();
                updateVisibility();
                render();
                scoreEl.textContent = score;
                stepsEl.textContent = steps;
                timerEl.textContent = timer;
                inventoryEl.textContent = 'None';
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timer++;
                    timerEl.textContent = timer;
                }, 1000);
                powerUpFogActive = false;
                powerUpMarkVisitedActive = false;
            }, 50);
        }

        function movePlayer(dx, dy) {
            if (!gameStarted) return;
            let nx = player.x + dx, ny = player.y + dy;
            if (nx >= 0 && ny >= 0 && nx < mapSize && ny < mapSize && maze[ny][nx].wall === false) {
                player.x = nx;
                player.y = ny;
                steps++;
                stepsEl.textContent = steps;
                maze[ny][nx].visited = true;
                if (!maze[ny][nx].explored) {
                    maze[ny][nx].explored = true;
                    score++;
                    scoreEl.textContent = score;
                }
                // Check for power-up
                for (let i = placedPowerUps.length - 1; i >= 0; i--) {
                    const p = placedPowerUps[i];
                    if (p.x === nx && p.y === ny) {
                        p.powerUp.isActive = true;
                        if (p.powerUp.type === 'fog') {
                            powerUpFogActive = true;
                        } else if (p.powerUp.type === 'markVisited') {
                            powerUpMarkVisitedActive = true;
                        } else if (p.powerUp.type === 'showPath') {
                            activateShowPathPowerUp(nx, ny);
                        } else if (p.powerUp.type === 'revealMap') {
                            revealMap = true;
                            renderFullMaze();
                            placedPowerUps.splice(i, 1);
                            return;
                        } else if (p.powerUp.type === 'showFullMap') {
                            showFullMapActive = true;
                        } else if (p.powerUp.type === 'followLocation') {
                            followLocationActive = true;
                        }
                        placedPowerUps.splice(i, 1);
                    }
                }
                updateVisibility();
                render();
                if (ny === exit.y && nx === exit.x) {
                    endGame(true);
                }
            }
        }

        function endGame(won) {
            gameStarted = false;
            if (timerInterval) clearInterval(timerInterval);
            // Show custom modal instead of alert
            const modal = document.getElementById('endgame-modal');
            const title = document.getElementById('endgame-title');
            const details = document.getElementById('endgame-details');
            title.textContent = won ? 'You Escaped the Maze!' : 'Game Over';
            details.innerHTML = won ? `<p>Score: <b>${score}</b></p><p>Time: <b>${timer}s</b></p>` : '';
            modal.style.display = 'flex';
            // Reveal the entire maze and show the full map with track
            revealMap = true;
            showFullMapActive = false;
            followLocationActive = false;
            renderFullMaze();
        }
        document.getElementById('close-endgame').onclick = function () {
            document.getElementById('endgame-modal').style.display = 'none';
        };

        let guidePath = null;
        let guideStep = 0;
        let guideActive = false;

        function activateShowPathPowerUp(px, py) {
            guidePath = findShortestPath(px, py, exit.x, exit.y);
            guideStep = 0;
            guideActive = true;
            animateGuide();
        }

        function animateGuide() {
            if (!guideActive || !guidePath || guideStep >= guidePath.length) {
                guideActive = false;
                guidePath = null;
                render();
                return;
            }
            render();
            guideStep++;
            setTimeout(animateGuide, 50); // Faster movement (was 120)
        }

        // --- Utility Functions ---
        function randInt(a, b) {
            return Math.floor(Math.random() * (b - a + 1)) + a;
        }

        function findDeadEnds() {
            let deadEnds = [];
            for (let y = 1; y < mapSize - 1; y++) {
                for (let x = 1; x < mapSize - 1; x++) {
                    if (maze[y][x].wall === false && !(x === player.x && y === player.y) && !(x === exit.x && y === exit.y)) {
                        let open = 0;
                        if (maze[y - 1][x].wall === false) open++;
                        if (maze[y + 1][x].wall === false) open++;
                        if (maze[y][x - 1].wall === false) open++;
                        if (maze[y][x + 1].wall === false) open++;
                        if (open === 1) deadEnds.push({ x, y });
                    }
                }
            }
            return deadEnds;
        }

        function findShortestPath(sx, sy, ex, ey) {
            let queue = [{ x: sx, y: sy, path: [] }];
            let visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
            visited[sy][sx] = true;
            while (queue.length > 0) {
                let { x, y, path } = queue.shift();
                if (x === ex && y === ey) return [...path, { x, y }];
                for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
                    let nx = x + dx, ny = y + dy;
                    if (nx >= 0 && ny >= 0 && nx < mapSize && ny < mapSize && !visited[ny][nx] && maze[ny][nx].wall === false) {
                        visited[ny][nx] = true;
                        queue.push({ x: nx, y: ny, path: [...path, { x, y }] });
                    }
                }
            }
            return null;
        }

        function isMazeFullyReachable() {
            // BFS from player, do not go through exit
            let visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
            let queue = [];
            queue.push({ x: player.x, y: player.y });
            visited[player.y][player.x] = true;
            while (queue.length > 0) {
                let { x, y } = queue.shift();
                for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
                    let nx = x + dx, ny = y + dy;
                    if (nx >= 0 && ny >= 0 && nx < mapSize && ny < mapSize && !visited[ny][nx]) {
                        if (maze[ny][nx].wall === false && !(nx === exit.x && ny === exit.y)) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            // Check all non-wall, non-exit cells are visited
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    if (maze[y][x].wall === false && !(x === exit.x && y === exit.y)) {
                        if (!visited[y][x]) return false;
                    }
                }
            }
            return true;
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            resizeCanvas();
            render();
        });
        document.addEventListener('keydown', e => {
            if (!gameStarted) return;
            if (e.key === 'ArrowUp' || e.key === 'w') movePlayer(0, -1);
            if (e.key === 'ArrowDown' || e.key === 's') movePlayer(0, 1);
            if (e.key === 'ArrowLeft' || e.key === 'a') movePlayer(-1, 0);
            if (e.key === 'ArrowRight' || e.key === 'd') movePlayer(1, 0);
        });
        startBtn.addEventListener('click', startGame);
        helpBtn.addEventListener('click', () => {
            helpModal.style.display = 'flex';
        });
        closeHelpBtn.addEventListener('click', () => {
            helpModal.style.display = 'none';
        });
        window.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            startGame();
        });
    </script>
</body>

</html>