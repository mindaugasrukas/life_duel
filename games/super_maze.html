<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Super Maze</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #222;
      color: #eee;
    }
    #game-container {
      position: relative;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }
    #maze-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: calc(100vw - 320px);
      height: 100vh;
      background: #181818;
      display: block;
      margin: 0;
    }
    #sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      height: 100vh;
      background: #2a2a2a;
      padding: 24px 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      border-left: 2px solid #444;
      z-index: 10;
    }
    #sidebar h2 {
      margin-top: 0;
      font-size: 1.4em;
      color: #ffd700;
    }
    .score, .steps, .timer, .inventory {
      margin-bottom: 18px;
      font-size: 1.1em;
    }
    #help-btn {
      background: #444;
      color: #ffd700;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 1.5em;
      cursor: pointer;
      margin-bottom: 16px;
    }
    #help-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      color: #fff;
      display: none;
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    #help-content {
      background: #333;
      padding: 32px;
      border-radius: 12px;
      max-width: 480px;
      box-shadow: 0 0 24px #000;
    }
    #close-help {
      margin-top: 24px;
      background: #444;
      color: #ffd700;
      border: none;
      padding: 8px 18px;
      border-radius: 6px;
      font-size: 1em;
      cursor: pointer;
    }
    #map-size-select {
      margin-bottom: 18px;
      font-size: 1.1em;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #222;
      color: #ffd700;
    }
    #start-btn {
      background: #ffd700;
      color: #222;
      border: none;
      border-radius: 6px;
      padding: 8px 18px;
      font-size: 1.1em;
      cursor: pointer;
      margin-bottom: 24px;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="maze-canvas"></canvas>
    <div id="sidebar">
      <h2>Super Maze</h2>
      <label for="map-size-select">Map Size:</label>
      <select id="map-size-select">
        <option value="11">11 x 11</option>
        <option value="25" selected>25 x 25</option>
        <option value="51">51 x 51</option>
        <option value="101">101 x 101</option>
      </select>
      <button id="start-btn">Start Game</button>
      <div class="score">Score: <span id="score">0</span></div>
      <div class="steps">Steps: <span id="steps">0</span></div>
      <div class="timer">Time: <span id="timer">0</span>s</div>
      <div class="inventory">Inventory: <span id="inventory">None</span></div>
      <button id="help-btn">?</button>
    </div>
  </div>
  <div id="help-modal">
    <div id="help-content">
      <h3>How to Play</h3>
      <ul>
        <li>Use arrow keys or WASD to move.</li>
        <li>Find the exit in the maze.</li>
        <li>Collect items and power-ups as you explore.</li>
        <li>Map view is fixed until you find location power-ups.</li>
        <li>Reveal the map with special power-ups.</li>
      </ul>
      <button id="close-help">Close</button>
    </div>
  </div>
  <script>
    // --- Game Constants ---
    const TILE_SIZE = 32;
    const VISIBLE_SIZE = 9; // 9x9 visible window
    // Map size is now selected directly as a number
    // --- Game State ---
    let mapSize = 25; // Default demo size
    let maze = [];
    let player = { x: 1, y: 1 };
    let exit = { x: 0, y: 0 };
    let score = 0;
    let steps = 0;
    let timer = 0;
    let inventory = [];
    let gameStarted = false;
    let revealMap = false;
    let followPlayer = false;
    let timerInterval = null;
    let powerUps = [
        {
            type: 'fog',
            color: '#a020f0',
            probability: 0.3,
            isActive: false
        },
        {
            type: 'markVisited',
            color: '#ff9800',
            probability: 0.5,
            isActive: false
        },
        {
            type: 'showPath',
            color: '#00ffea',
            probability: 0.1,
            isActive: false
        }
    ]
    let placedPowerUps = [];
    let powerUpFogActive = false;
    let powerUpMarkVisitedActive = false;
    // --- DOM Elements ---
    const canvas = document.getElementById('maze-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const stepsEl = document.getElementById('steps');
    const timerEl = document.getElementById('timer');
    const inventoryEl = document.getElementById('inventory');
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const closeHelpBtn = document.getElementById('close-help');
    const mapSizeSelect = document.getElementById('map-size-select');
    const startBtn = document.getElementById('start-btn');

    // --- Utility Functions ---
    function randInt(a, b) {
      return Math.floor(Math.random() * (b - a + 1)) + a;
    }

    // --- Maze Generation (Recursive Backtracker) ---
    function generateMaze(size) {
      // Initialize maze with walls
      maze = Array(size).fill().map(() =>
          Array(size).fill().map(() => ({ wall: true, visited: false, explored: false }))
      );
      let stack = [];
      let startX = 1, startY = 1;
      stack.push([startX, startY]);
      maze[startY][startX] = { wall: false, visited: true, explored: true };
      while (stack.length > 0) {
        let [x, y] = stack[stack.length - 1];
        let dirs = [ [0,-2], [0,2], [-2,0], [2,0] ];
        dirs = dirs.sort(() => Math.random()-0.5);
        let carved = false;
        for (let [dx, dy] of dirs) {
          let nx = x + dx, ny = y + dy;
          if (nx > 0 && ny > 0 && nx < size && ny < size && maze[ny][nx].wall === true) {
            maze[y + dy/2][x + dx/2].wall = false;
            maze[ny][nx].wall = false;
            stack.push([nx, ny]);
            carved = true;
            break;
          }
        }
        if (!carved) {
          stack.pop();
        }
      }
      // Place exit
      exit = { x: size-2, y: size-2 };
    }

    function findDeadEnds() {
      let deadEnds = [];
      for (let y = 1; y < mapSize-1; y++) {
        for (let x = 1; x < mapSize-1; x++) {
          if (maze[y][x].wall === false && !(x === player.x && y === player.y) && !(x === exit.x && y === exit.y)) {
            let open = 0;
            if (maze[y-1][x].wall === false) open++;
            if (maze[y+1][x].wall === false) open++;
            if (maze[y][x-1].wall === false) open++;
            if (maze[y][x+1].wall === false) open++;
            if (open === 1) deadEnds.push({x, y});
          }
        }
      }
      return deadEnds;
    }

    function placePowerUps() {
      placedPowerUps = [];
      let deadEnds = findDeadEnds();
      // If not enough dead-ends, regenerate maze
      let tries = 0;
      while (deadEnds.length < 4 && tries < 10) {
        generateMaze(mapSize);
        deadEnds = findDeadEnds();
        tries++;
      }
      let count = Math.min(deadEnds.length, randInt(4, Math.min(10, deadEnds.length)));
      let chosen = [];
      let used = new Set();
      while (chosen.length < count) {
        let idx = randInt(0, deadEnds.length-1);
        let key = `${deadEnds[idx].x},${deadEnds[idx].y}`;
        if (!used.has(key)) {
          chosen.push(deadEnds[idx]);
          used.add(key);
        }
      }
      let totalProb = powerUps.reduce((sum, p) => sum + p.probability, 0);
      for (let i = 0; i < chosen.length; i++) {
        let pos = chosen[i];
        const randomPowerUp = getRandomPowerUp();
        placedPowerUps.push({powerUp: randomPowerUp, x: pos.x, y: pos.y});
      }
    }

    // Get a random power-up by wieghted probability
    function getRandomPowerUp() {
      let totalProb = powerUps.reduce((sum, p) => sum + p.probability, 0);
      let rand = Math.random() * totalProb;
      for (const p of powerUps) {
        if (rand < p.probability) {
          return p;
        }
        rand -= p.probability;
      }
      return null;
    }

    // --- Rendering ---
    function resizeCanvas() {
      // Set both CSS and element attributes for canvas size
      const w = window.innerWidth - 320;
      const h = window.innerHeight;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = w;
      canvas.height = h;
    }

    function render() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Center visible window
      let px = player.x, py = player.y;
      let half = Math.floor(VISIBLE_SIZE/2);
      let vx = px - half, vy = py - half;
      if (followPlayer || revealMap || powerUpFogActive) {
        vx = Math.max(0, Math.min(mapSize-VISIBLE_SIZE, px-half));
        vy = Math.max(0, Math.min(mapSize-VISIBLE_SIZE, py-half));
      } else {
        vx = Math.floor((mapSize-VISIBLE_SIZE)/2);
        vy = Math.floor((mapSize-VISIBLE_SIZE)/2);
      }
      for (let y=0; y<VISIBLE_SIZE; y++) {
        for (let x=0; x<VISIBLE_SIZE; x++) {
          let mx = vx+x, my = vy+y;
          let tile = maze[my]?.[mx] ?? { wall: true };
          let sx = x*TILE_SIZE + (canvas.width-VISIBLE_SIZE*TILE_SIZE)/2;
          let sy = y*TILE_SIZE + (canvas.height-VISIBLE_SIZE*TILE_SIZE)/2;
          // Fog of war logic
          if (powerUpFogActive && !tile.explored) {
            ctx.fillStyle = '#111';
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
            continue;
          }
          if (!powerUpFogActive && !revealMap && !isTileVisible(mx, my)) {
            ctx.fillStyle = '#111';
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
            continue;
          }
          if (exit && mx === exit.x && my === exit.y) {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          } else if (tile.wall === true) {
            ctx.fillStyle = '#444';
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          } else if (powerUpMarkVisitedActive && tile.visited) {
            ctx.fillStyle = '#b7e4c7';
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          } else if (tile.wall === false) {
            ctx.fillStyle = '#eee';
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          }
          // Draw power-ups
          for (const p of placedPowerUps) {
            if (p.x === mx && p.y === my) {
              ctx.fillStyle = p.powerUp.color;
              ctx.beginPath();
              ctx.arc(sx+TILE_SIZE/2, sy+TILE_SIZE/2, TILE_SIZE/3, 0, 2*Math.PI);
              ctx.fill();
            }
          }
          // Draw guide path if active
          if (guideActive && guidePath) {
            for (let i = 0; i < guideStep; i++) {
              let gp = guidePath[i];
              let gx = gp.x - vx, gy = gp.y - vy;
              if (gx >= 0 && gx < VISIBLE_SIZE && gy >= 0 && gy < VISIBLE_SIZE) {
                let sx = gx*TILE_SIZE + (canvas.width-VISIBLE_SIZE*TILE_SIZE)/2;
                let sy = gy*TILE_SIZE + (canvas.height-VISIBLE_SIZE*TILE_SIZE)/2;
                ctx.fillStyle = '#00ffea';
                ctx.fillRect(sx+TILE_SIZE/4, sy+TILE_SIZE/4, TILE_SIZE/2, TILE_SIZE/2);
              }
            }
          }
          // Player
          if (mx === player.x && my === player.y) {
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(sx+TILE_SIZE/2, sy+TILE_SIZE/2, TILE_SIZE/2.2, 0, 2*Math.PI);
            ctx.fill();
          }
        }
      }
    }
    // --- Fog of War ---
    let visibleTiles = new Set();
    function isTileVisible(x, y) {
      return visibleTiles.has(`${x},${y}`);
    }

    function updateVisibility() {
      let radius = 4;
      for (let dy=-radius; dy<=radius; dy++) {
        for (let dx=-radius; dx<=radius; dx++) {
          let nx = player.x+dx, ny = player.y+dy;
          if (nx>=0 && ny>=0 && nx<mapSize && ny<mapSize) {
            visibleTiles.add(`${nx},${ny}`);
            // Only mark as explored in movePlayer
          }
        }
      }
    }

    // --- Game Logic ---
    function isMazeFullyReachable() {
      // BFS from player, do not go through exit
      let visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
      let queue = [];
      queue.push({x: player.x, y: player.y});
      visited[player.y][player.x] = true;
      while (queue.length > 0) {
        let {x, y} = queue.shift();
        for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
          let nx = x+dx, ny = y+dy;
          if (nx>=0 && ny>=0 && nx<mapSize && ny<mapSize && !visited[ny][nx]) {
            if (maze[ny][nx].wall === false && !(nx === exit.x && ny === exit.y)) {
              visited[ny][nx] = true;
              queue.push({x: nx, y: ny});
            }
          }
        }
      }
      // Check all non-wall, non-exit cells are visited
      for (let y=0; y<mapSize; y++) {
        for (let x=0; x<mapSize; x++) {
          if (maze[y][x].wall === false && !(x === exit.x && y === exit.y)) {
            if (!visited[y][x]) return false;
          }
        }
      }
      return true;
    }

    function startGame() {
      mapSize = parseInt(mapSizeSelect.value);
      // Show loading indicator for large mazes
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffd700';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Generating maze...', canvas.width/2, canvas.height/2);
      setTimeout(() => {
        let tries = 0;
        do {
          generateMaze(mapSize);
          // Find a valid starting position (first open path near top-left)
          let found = false;
          for (let y = 1; y < Math.min(10, mapSize) && !found; y++) {
            for (let x = 1; x < Math.min(10, mapSize) && !found; x++) {
              if (maze[y][x].wall === false) {
                player = { x, y };
                found = true;
              }
            }
          }
          if (!found) player = { x: 1, y: 1 };
          exit = { x: mapSize-2, y: mapSize-2 };
          tries++;
        } while (!isMazeFullyReachable() && tries < 20);
        score = 0;
        steps = 0;
        timer = 0;
        inventory = [];
        visibleTiles = new Set();
        // Always show full maze and follow player
        revealMap = true;
        followPlayer = true;
        gameStarted = true;
        // Mark starting cell as visited and explored
        maze[player.y][player.x].visited = true;
        if (!maze[player.y][player.x].explored) {
          maze[player.y][player.x].explored = true;
          score = 1;
          scoreEl.textContent = score;
        }
        placePowerUps();
        updateVisibility();
        render();
        scoreEl.textContent = score;
        stepsEl.textContent = steps;
        timerEl.textContent = timer;
        inventoryEl.textContent = 'None';
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          timer++;
          timerEl.textContent = timer;
        }, 1000);
        powerUpFogActive = false;
        powerUpMarkVisitedActive = false;
      }, 50);
    }

    function movePlayer(dx, dy) {
      if (!gameStarted) return;
      let nx = player.x+dx, ny = player.y+dy;
      if (nx>=0 && ny>=0 && nx<mapSize && ny<mapSize && maze[ny][nx].wall === false) {
        player.x = nx;
        player.y = ny;
        steps++;
        stepsEl.textContent = steps;
        maze[ny][nx].visited = true;
        if (!maze[ny][nx].explored) {
          maze[ny][nx].explored = true;
          score++;
          scoreEl.textContent = score;
        }
        // Check for power-up
        for (let i=placedPowerUps.length-1; i>=0; i--) {
          const p = placedPowerUps[i];
          if (p.x === nx && p.y === ny) {
            p.powerUp.isActive = true;
            if (p.powerUp.type === 'fog') {
              powerUpFogActive = true;
            } else if (p.powerUp.type === 'markVisited') {
              powerUpMarkVisitedActive = true;
            } else if (p.powerUp.type === 'showPath') {
              activateShowPathPowerUp(nx, ny);
            }
            placedPowerUps.splice(i, 1);
          }
        }
        updateVisibility();
        render();
        if (ny === exit.y && nx === exit.x) {
          endGame(true);
        }
      }
    }

    function endGame(won) {
      gameStarted = false;
      if (timerInterval) clearInterval(timerInterval);
      // Reveal the entire maze and show the full map with track
      revealMap = true;
      renderFullMaze();
      setTimeout(() => {
        alert(won ? `You escaped the maze!\nScore: ${score}\nTime: ${timer}s` : 'Game Over');
      }, 100);
    }

    function renderFullMaze() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Calculate tile size to fit the whole maze in the canvas
      let tileSize = Math.min((canvas.width-10)/mapSize, (canvas.height-10)/mapSize);
      let offsetX = (canvas.width - tileSize*mapSize)/2;
      let offsetY = (canvas.height - tileSize*mapSize)/2;
      for (let y=0; y<mapSize; y++) {
        for (let x=0; x<mapSize; x++) {
          let tile = maze[y][x];
          let sx = offsetX + x*tileSize;
          let sy = offsetY + y*tileSize;
          if (exit && x === exit.x && y === exit.y) {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(sx, sy, tileSize, tileSize);
          } else if (tile.wall === true) {
            ctx.fillStyle = '#444';
            ctx.fillRect(sx, sy, tileSize, tileSize);
          } else if (tile.visited) {
            ctx.fillStyle = '#b7e4c7'; // visited cell color
            ctx.fillRect(sx, sy, tileSize, tileSize);
          } else if (tile.explored) {
            ctx.fillStyle = '#8ecae6'; // explored cell color
            ctx.fillRect(sx, sy, tileSize, tileSize);
          } else if (tile.wall === false) {
            ctx.fillStyle = '#eee';
            ctx.fillRect(sx, sy, tileSize, tileSize);
          }
          if (x === player.x && y === player.y) {
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(sx+tileSize/2, sy+tileSize/2, tileSize/2.2, 0, 2*Math.PI);
            ctx.fill();
          }
          // Draw power-ups
          for (const p of placedPowerUps) {
            if (p.x === x && p.y === y) {
              ctx.fillStyle = p.powerUp.color;
              ctx.beginPath();
              ctx.arc(sx+tileSize/2, sy+tileSize/2, tileSize/3, 0, 2*Math.PI);
              ctx.fill();
            }
          }
        }
      }
    }

    function findShortestPath(sx, sy, ex, ey) {
      let queue = [{x: sx, y: sy, path: []}];
      let visited = Array(mapSize).fill().map(() => Array(mapSize).fill(false));
      visited[sy][sx] = true;
      while (queue.length > 0) {
        let {x, y, path} = queue.shift();
        if (x === ex && y === ey) return [...path, {x, y}];
        for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
          let nx = x+dx, ny = y+dy;
          if (nx>=0 && ny>=0 && nx<mapSize && ny<mapSize && !visited[ny][nx] && maze[ny][nx].wall === false) {
            visited[ny][nx] = true;
            queue.push({x: nx, y: ny, path: [...path, {x, y}]});
          }
        }
      }
      return null;
    }

    let guidePath = null;
    let guideStep = 0;
    let guideActive = false;

    function activateShowPathPowerUp(px, py) {
      guidePath = findShortestPath(px, py, exit.x, exit.y);
      guideStep = 0;
      guideActive = true;
      animateGuide();
    }

    function animateGuide() {
      if (!guideActive || !guidePath || guideStep >= guidePath.length) {
        guideActive = false;
        guidePath = null;
        render();
        return;
      }
      render();
      guideStep++;
      setTimeout(animateGuide, 50); // Faster movement (was 120)
    }

    // --- Event Listeners ---
    window.addEventListener('resize', () => {
      resizeCanvas();
      render();
    });
    document.addEventListener('keydown', e => {
      if (!gameStarted) return;
      if (e.key === 'ArrowUp' || e.key === 'w') movePlayer(0,-1);
      if (e.key === 'ArrowDown' || e.key === 's') movePlayer(0,1);
      if (e.key === 'ArrowLeft' || e.key === 'a') movePlayer(-1,0);
      if (e.key === 'ArrowRight' || e.key === 'd') movePlayer(1,0);
    });
    startBtn.addEventListener('click', startGame);
    helpBtn.addEventListener('click', () => {
      helpModal.style.display = 'flex';
    });
    closeHelpBtn.addEventListener('click', () => {
      helpModal.style.display = 'none';
    });
    window.addEventListener('DOMContentLoaded', () => {
      resizeCanvas();
      startGame();
    });
    </script>
</body>
</html>
