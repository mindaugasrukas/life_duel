<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Super Maze</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
        }

        #game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #maze-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100vw - 320px);
            height: 100vh;
            background: #181818;
            display: block;
            margin: 0;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #2a2a2a;
            padding: 24px 16px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            border-left: 2px solid #444;
            z-index: 10;
        }

        #sidebar h2 {
            margin-top: 0;
            font-size: 1.4em;
            color: #ffd700;
        }

        .score,
        .steps,
        .timer,
        .inventory {
            margin-bottom: 18px;
            font-size: 1.1em;
        }

        #help-btn {
            background: #444;
            color: #ffd700;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            cursor: pointer;
            margin-bottom: 16px;
        }

        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #help-content {
            background: #333;
            padding: 32px;
            border-radius: 12px;
            max-width: 480px;
            box-shadow: 0 0 24px #000;
        }

        #close-help {
            margin-top: 24px;
            background: #444;
            color: #ffd700;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }

        #map-size-select {
            margin-bottom: 18px;
            font-size: 1.1em;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: #ffd700;
        }

        #start-btn {
            background: #ffd700;
            color: #222;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            font-size: 1.1em;
            cursor: pointer;
            margin-bottom: 24px;
        }

        #endgame-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        #endgame-modal>div {
            background: #333;
            color: #ffd700;
            padding: 32px;
            border-radius: 12px;
            max-width: 400px;
            box-shadow: 0 0 24px #000;
            text-align: center;
        }

        #endgame-modal #close-endgame {
            margin-top: 24px;
            background: #444;
            color: #ffd700;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }

        .home-link {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            text-decoration: none;
            color: #fff;
            font-size: 1.1em;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="maze-canvas"></canvas>
        <div id="sidebar">
            <a href="../index.html" title="Back to Home" class="home-link">
                <svg width="28" height="28" viewBox="0 0 24 24">
                    <path d="M15 18l-6-6 6-6" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Home</span>
            </a>
            <h2>Super Maze</h2>
            <label for="map-size-select">Map Size:</label>
            <select id="map-size-select">
                <option value="11">11 x 11</option>
                <option value="25" selected>25 x 25</option>
                <option value="51">51 x 51</option>
                <option value="101">101 x 101</option>
            </select>
            <button id="start-btn">Start Game</button>
            <div class="score">Score: <span id="score">0</span></div>
            <div class="steps">Steps: <span id="steps">0</span></div>
            <div class="timer">Time: <span id="timer">0</span>s</div>
            <div class="inventory">Inventory: <span id="inventory">None</span></div>
            <button id="help-btn">?</button>
        </div>
    </div>
    <div id="help-modal">
        <div id="help-content">
            <h3>How to Play</h3>
            <ul>
                <li>Use arrow keys or WASD to move.</li>
                <li>Find the exit in the maze.</li>
                <li>Collect items and power-ups as you explore.</li>
                <li>Map view is fixed until you find location power-ups.</li>
                <li>Reveal the map with special power-ups.</li>
            </ul>
            <button id="close-help">Close</button>
        </div>
    </div>
    <div id="endgame-modal">
        <div>
            <h3 id="endgame-title"></h3>
            <div id="endgame-details"></div>
            <button id="close-endgame">Close</button>
        </div>
    </div>
    <div id="info-modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:1500; justify-content:center; align-items:center;">
        <div style="background:#333; color:#ffd700; padding:24px; border-radius:12px; max-width:420px; text-align:center; box-shadow:0 0 24px #000;">
            <h3 id="info-title">Power-Up Activated</h3>
            <div id="info-content"></div>
            <button id="close-info" style="margin-top:16px; background:#444; color:#ffd700; border:none; padding:8px 18px; border-radius:6px; cursor:pointer;">Got it</button>
        </div>
    </div>
    <!-- Toast notification for power-ups -->
    <div id="toast" style="position:fixed; bottom:24px; right:24px; background:rgba(51,51,51,0.95); color:#ffd700; padding:12px 16px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.4); display:none; opacity:0; transition:opacity 0.6s ease; z-index:1600;
    font-family: Arial, sans-serif;">
        <span id="toast-text"></span>
    </div>
    <script>
        /*
            TODO:
                - place power-ups more evenly throughout the maze
                - refactor powerUp.isActive flags
                - refactor the exit as special power-up
        */

        // Event Emitter (for decoupled architecture)
        class EventEmitter {
            constructor() { this.events = {}; }
            on(event, listener) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(listener);
                return () => this.off(event, listener);
            }
            off(event, listener) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(l => l !== listener);
            }
            emit(event, ...args) {
                if (!this.events[event]) return;
                for (const l of this.events[event]) { try { l(...args); } catch (e) { console.error(e); } }
            }
        }

        // Core Game class (encapsulated state)
        class SuperMazeGame extends EventEmitter {
            constructor() {
                super();

                // Game State
                this.mapSize = 25; // Default map size
                this.maze = []; // Maze grid
                this.player = { x: 1, y: 1 }; // Player position
                this.exit = { x: 0, y: 0 }; // Exit position
                this.score = 0; // Player score
                this.steps = 0; // Steps taken
                this.timer = 0; // Time elapsed
                this.placedPowerUps = []; // Placed power-ups in the maze
                this.inventory = []; // TBD, not used yet
                this.timerInterval = null; // Timer interval ID
                this.visibleTiles = new Set(); // Currently visible tiles

                // Game Flags
                this.gameStarted = false; // Is game started
                this.revealMap = false; // Reveal entire map
                this.followPlayer = false; // Follow player location
                this.powerUpFogActive = false; // Fog of war active
                this.powerUpMarkVisitedActive = false; // Mark visited active
                this.showFullMapActive = false; // Show full map active
                this.followLocationActive = false; // Follow location active
                // Movement animation flags
                this.isSliding = false;

                this.powerUps = [
                    {
                        type: 'fog',
                        description: 'Fog of War: Hides unvisited areas of the maze',
                        color: '#a020f0', // purple
                        probability: 0.3,
                        // isActive: false // TODO: not used yet
                    },
                    {
                        type: 'markVisited',
                        description: 'Mark Visited: Marks all visited tiles on the map',
                        color: '#ff9800', // orange
                        probability: 0.5,
                    },
                    {
                        type: 'showPath',
                        description: 'Show Path: Reveals the optimal path to the exit',
                        color: '#00ffea', // cyan
                        probability: 0.1,
                    },
                    {
                        type: 'revealMap',
                        description: 'Reveal Map: Shows the entire maze layout until moved',
                        color: '#00ff00', // green
                        probability: 0.1,
                    },
                    {
                        type: 'showFullMap',
                        description: 'Show Full Map: Permanently reveals the entire maze',
                        color: '#0000ff', // blue
                        probability: 0.1,
                    },
                    {
                        type: 'followLocation',
                        description: 'Follow Location: Shows full map, but only viewport is visible, rest is dark',
                        color: '#ff00ff', // magenta
                        probability: 0.1,
                    }
                ];
            }

            startGame(size) {
                this.mapSize = typeof size === 'number' ? size : this.mapSize;
                // Reset basic state
                this.score = 0;
                this.steps = 0;
                this.timer = 0;
                this.inventory = [];
                this.visibleTiles = new Set();
                // Start with hidden map; visibility will be computed around the player
                this.revealMap = false;
                this.followPlayer = true;
                this.gameStarted = true;
                // Reset view-related flags
                this.showFullMapActive = false;
                this.followLocationActive = false;
                this.powerUpFogActive = false;
                this.powerUpMarkVisitedActive = false;
                // Generate and choose start
                let tries = 0;
                do {
                    this.generateMaze(this.mapSize);
                    let found = false;
                    for (let y = 1; y < Math.min(10, this.mapSize) && !found; y++) {
                        for (let x = 1; x < Math.min(10, this.mapSize) && !found; x++) {
                            if (this.maze[y][x].wall === false) {
                                this.player = { x, y };
                                found = true;
                            }
                        }
                    }
                    if (!found) this.player = { x: 1, y: 1 };
                    this.exit = { x: this.mapSize - 2, y: this.mapSize - 2 };
                    tries++;
                } while (!this.isMazeFullyReachable() && tries < 20);
                // Mark starting cell
                this.maze[this.player.y][this.player.x].visited = true;
                if (!this.maze[this.player.y][this.player.x].explored) {
                    this.maze[this.player.y][this.player.x].explored = true;
                    this.score = 1;
                }
                // Power-ups and visibility
                this.placePowerUps();
                this.updateVisibility();
                // Timer
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    this.emit('timerUpdated', this.timer);
                }, 1000);
                // Notify listeners
                this.emit('gameStarted', this.getState());
            }

            movePlayer(dx, dy) {
                if (!this.gameStarted) return;
                // If Reveal Map was previously activated, turn it off on the next move
                if (this.revealMap) {
                    this.revealMap = false;
                }
                let nx = this.player.x + dx, ny = this.player.y + dy;
                if (nx >= 0 && ny >= 0 && nx < this.mapSize && ny < this.mapSize && this.maze[ny][nx].wall === false) {
                    this.player.x = nx;
                    this.player.y = ny;
                    this.steps++;
                    this.maze[ny][nx].visited = true;
                    if (!this.maze[ny][nx].explored) {
                        this.maze[ny][nx].explored = true;
                        this.score++;
                    }
                    // Power-ups
                    for (let i = this.placedPowerUps.length - 1; i >= 0; i--) {
                        const p = this.placedPowerUps[i];
                        if (p.x === nx && p.y === ny) {
                            if (p.powerUp.type === 'fog') {
                                this.powerUpFogActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'markVisited') {
                                this.powerUpMarkVisitedActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'showPath') {
                                this.emit('showPathActivated', { x: nx, y: ny });
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'revealMap') {
                                this.revealMap = true;
                                this.placedPowerUps.splice(i, 1);
                                this.emit('revealMapActivated');
                                this.emit('stateUpdated', this.getState());
                                return;
                            } else if (p.powerUp.type === 'showFullMap') {
                                this.showFullMapActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'followLocation') {
                                this.followLocationActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            }
                            this.placedPowerUps.splice(i, 1);
                        }
                    }
                    this.updateVisibility();
                    this.emit('stateUpdated', this.getState());
                    if (ny === this.exit.y && nx === this.exit.x) {
                        this.endGame(true);
                    }
                }
            }

            // Slide movement: animate step-by-step until hitting a wall or boundary
            slideMove(dx, dy) {
                if (!this.gameStarted || this.isSliding) return;
                // Turn off temporary reveal on first slide move
                if (this.revealMap) this.revealMap = false;
                // Only allow cardinal directions
                if (!((dx === 0 && (dy === 1 || dy === -1)) || (dy === 0 && (dx === 1 || dx === -1)))) return;
                this.isSliding = true;
                const stepMs = 60; // animation speed: ~16 tiles/sec
                const doStep = () => {
                    const nx = this.player.x + dx;
                    const ny = this.player.y + dy;
                    if (nx < 0 || ny < 0 || nx >= this.mapSize || ny >= this.mapSize || this.maze[ny][nx].wall === true) {
                        // stop sliding
                        this.isSliding = false;
                        this.updateVisibility();
                        this.emit('stateUpdated', this.getState());
                        return;
                    }
                    // Move one step
                    this.player.x = nx;
                    this.player.y = ny;
                    this.steps++;
                    const tile = this.maze[ny][nx];
                    tile.visited = true;
                    if (!tile.explored) {
                        tile.explored = true;
                        this.score++;
                    }
                    // Collect power-ups on the way
                    for (let i = this.placedPowerUps.length - 1; i >= 0; i--) {
                        const p = this.placedPowerUps[i];
                        if (p.x === nx && p.y === ny) {
                            if (p.powerUp.type === 'fog') {
                                this.powerUpFogActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'markVisited') {
                                this.powerUpMarkVisitedActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'showPath') {
                                this.emit('showPathActivated', { x: nx, y: ny });
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'revealMap') {
                                this.revealMap = true;
                                this.placedPowerUps.splice(i, 1);
                                this.emit('revealMapActivated');
                                this.emit('stateUpdated', this.getState());
                                // Stop slide to let player inspect; resume after next input
                                this.isSliding = false;
                                this.updateVisibility();
                                return;
                            } else if (p.powerUp.type === 'showFullMap') {
                                this.showFullMapActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            } else if (p.powerUp.type === 'followLocation') {
                                this.followLocationActive = true;
                                this.emit('powerUpCollected', p.powerUp);
                            }
                            this.placedPowerUps.splice(i, 1);
                        }
                    }
                    // Exit reached
                    if (ny === this.exit.y && nx === this.exit.x) {
                        this.isSliding = false;
                        this.updateVisibility();
                        this.emit('stateUpdated', this.getState());
                        this.endGame(true);
                        return;
                    }
                    // intermediate repaint
                    this.updateVisibility();
                    this.emit('stateUpdated', this.getState());
                    setTimeout(doStep, stepMs);
                };
                setTimeout(doStep, stepMs);
            }

            endGame(won) {
                this.gameStarted = false;
                if (this.timerInterval) clearInterval(this.timerInterval);
                // Reveal the entire maze and reset special views
                this.revealMap = true;
                this.showFullMapActive = false;
                this.followLocationActive = false;
                // Notify listeners; UIController/Renderer will handle modal/rendering
                this.emit('gameEnded', { won, score: this.score, timer: this.timer });
            }

            updateVisibility() {
                const radius = 4;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        let nx = this.player.x + dx, ny = this.player.y + dy;
                        if (nx >= 0 && ny >= 0 && nx < this.mapSize && ny < this.mapSize) {
                            this.visibleTiles.add(`${nx},${ny}`);
                            // Distinguish explored vs visited: mark any visible non-wall tiles as explored
                            const tile = this.maze[ny][nx];
                            if (tile && tile.wall === false && !tile.explored) {
                                tile.explored = true;
                                // Optional: score for exploration only when first seen, not required
                                // this.score++;
                            }
                        }
                    }
                }
                this.emit('visibilityUpdated', this.visibleTiles);
                // Notify state update so renderer/UI can reflect exploration changes
                this.emit('stateUpdated', this.getState());
            }

            getState() {
                return {
                    mapSize: this.mapSize,
                    maze: this.maze,
                    player: this.player,
                    exit: this.exit,
                    score: this.score,
                    steps: this.steps,
                    timer: this.timer,
                    placedPowerUps: this.placedPowerUps,
                    inventory: this.inventory,
                    gameStarted: this.gameStarted,
                    revealMap: this.revealMap,
                    followPlayer: this.followPlayer,
                    powerUpFogActive: this.powerUpFogActive,
                    powerUpMarkVisitedActive: this.powerUpMarkVisitedActive,
                    showFullMapActive: this.showFullMapActive,
                    followLocationActive: this.followLocationActive,
                    visibleTiles: this.visibleTiles
                };
            }

            // Maze Generation (Recursive Backtracker)
            generateMaze(size) {
                // Initialize maze with walls
                this.maze = Array(size).fill().map(() =>
                    Array(size).fill().map(() => ({ wall: true, visited: false, explored: false }))
                );
                let stack = [];
                let startX = 1, startY = 1;
                stack.push([startX, startY]);
                this.maze[startY][startX] = { wall: false, visited: true, explored: true };
                while (stack.length > 0) {
                    let [x, y] = stack[stack.length - 1];
                    let dirs = [[0, -2], [0, 2], [-2, 0], [2, 0]];
                    dirs = dirs.sort(() => Math.random() - 0.5);
                    let carved = false;
                    for (let [dx, dy] of dirs) {
                        let nx = x + dx, ny = y + dy;
                        if (nx > 0 && ny > 0 && nx < size && ny < size && this.maze[ny][nx].wall === true) {
                            this.maze[y + dy / 2][x + dx / 2].wall = false;
                            this.maze[ny][nx].wall = false;
                            stack.push([nx, ny]);
                            carved = true;
                            break;
                        }
                    }
                    if (!carved) {
                        stack.pop();
                    }
                }
                // Place exit
                this.exit = { x: size - 2, y: size - 2 };
                // Add loops and multiple paths by removing additional walls between adjacent corridors
                this.addLoops(size);
                this.emit('mazeGenerated', this.maze);
            }

            // Post-process the perfect maze to introduce cycles and alternative routes
            addLoops(size) {
                // Target: remove a fraction of walls that separate two open cells to create cycles.
                // Keep boundaries intact and avoid overwhelming the maze.
                const loopRatio = 0.01; // ~1% of candidate walls, slightly lower to reduce openness
                const candidates = [];
                for (let y = 1; y < size - 1; y++) {
                    for (let x = 1; x < size - 1; x++) {
                        // Consider vertical walls between two open cells
                        if (this.maze[y][x].wall === true) {
                            const up = this.maze[y - 1]?.[x];
                            const down = this.maze[y + 1]?.[x];
                            if (up && down && up.wall === false && down.wall === false) {
                                candidates.push({ x, y });
                                continue;
                            }
                            const left = this.maze[y]?.[x - 1];
                            const right = this.maze[y]?.[x + 1];
                            if (left && right && left.wall === false && right.wall === false) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                }
                // Shuffle and remove a subset
                candidates.sort(() => Math.random() - 0.5);
                const removeCount = Math.floor(candidates.length * loopRatio);
                const removed = [];
                let removedSoFar = 0;
                for (let i = 0; i < candidates.length && removedSoFar < removeCount; i++) {
                    const { x, y } = candidates[i];
                    // Avoid opening the extreme border to preserve outer wall
                    if (x <= 0 || y <= 0 || x >= size - 1 || y >= size - 1) continue;
                    // Avoid clustering: keep at least 2 tiles apart from previously removed walls
                    const tooClose = removed.some(r => Math.abs(r.x - x) <= 2 && Math.abs(r.y - y) <= 2);
                    if (tooClose) continue;
                    // Prevent creating 2x2 open areas
                    if (this.createsOpenSquare(x, y)) continue;
                    // Ensure the cycle formed is not trivially small inside a 9x9 view
                    // Find the two open neighbors separated by this wall
                    const neighbors = [];
                    if (this.maze[y-1]?.[x]?.wall === false) neighbors.push({x, y: y-1});
                    if (this.maze[y+1]?.[x]?.wall === false) neighbors.push({x, y: y+1});
                    if (this.maze[y]?.[x-1]?.wall === false) neighbors.push({x: x-1, y});
                    if (this.maze[y]?.[x+1]?.wall === false) neighbors.push({x: x+1, y});
                    if (neighbors.length === 2) {
                        const a = neighbors[0], b = neighbors[1];
                        const cycleLen = this.pathLength(a.x, a.y, b.x, b.y);
                        // If the path around is very short, skip to avoid simple cycles
                        if (cycleLen !== null && cycleLen <= VISIBLE_SIZE * 2) continue;
                    }
                    // All checks passed; remove wall
                    this.maze[y][x].wall = false;
                    removed.push({ x, y });
                    console.log(`Removed wall at (${x},${y}) to create loop`);
                    removedSoFar++;
                }
            }

            // Check if removing a wall at (x,y) would create any 2x2 open block
            createsOpenSquare(x, y) {
                // Temporarily consider (x,y) open and check 2x2 patterns around
                const openAt = (cx, cy) => {
                    if (cx === x && cy === y) return true;
                    const t = this.maze[cy]?.[cx];
                    return t && t.wall === false;
                };
                for (let dy = -1; dy <= 0; dy++) {
                    for (let dx = -1; dx <= 0; dx++) {
                        const x0 = x + dx, y0 = y + dy;
                        if (openAt(x0, y0) && openAt(x0+1, y0) && openAt(x0, y0+1) && openAt(x0+1, y0+1)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // Compute shortest path length between two open cells without removing the wall
            pathLength(sx, sy, ex, ey) {
                if (sx === ex && sy === ey) return 0;
                const visited = Array(this.mapSize).fill().map(() => Array(this.mapSize).fill(false));
                const q = [{x: sx, y: sy, d: 0}];
                visited[sy][sx] = true;
                while (q.length) {
                    const {x, y, d} = q.shift();
                    if (x === ex && y === ey) return d;
                    for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && ny >= 0 && nx < this.mapSize && ny < this.mapSize && !visited[ny][nx]) {
                            const t = this.maze[ny][nx];
                            if (t && t.wall === false) {
                                visited[ny][nx] = true;
                                q.push({x: nx, y: ny, d: d+1});
                            }
                        }
                    }
                }
                return null;
            }

            // Place Power-Ups in Dead-Ends of the Maze
            placePowerUps() {
                this.placedPowerUps = [];
                let deadEnds = this.findDeadEnds();
                // If not enough dead-ends, regenerate maze
                let tries = 0;
                while (deadEnds.length < this.powerUps.length && tries < 10) {
                    this.generateMaze(this.mapSize);
                    deadEnds = this.findDeadEnds();
                    tries++;
                }
                // Calculate number of power-ups based on maze size
                let ratio = 1/60; // 1 power-up per 60 cells
                let minPowerUps = this.powerUps.length;
                let maxPowerUps = Math.max(minPowerUps, Math.floor(this.mapSize * this.mapSize / 8));
                let count = Math.max(minPowerUps, Math.min(deadEnds.length, Math.round(this.mapSize * this.mapSize * ratio)));
                count = Math.min(count, maxPowerUps);
                // Ensure every power-up is included at least once
                let chosen = [];
                // Place one of each power-up type
                for (let i = 0; i < this.powerUps.length && deadEnds.length > 0; i++) {
                    let idx = this.randInt(0, deadEnds.length - 1);
                    let pos = deadEnds.splice(idx, 1)[0];
                    chosen.push({ powerUp: this.powerUps[i], x: pos.x, y: pos.y });
                }
                // Fill the rest randomly
                while (chosen.length < count && deadEnds.length > 0) {
                    let idx = this.randInt(0, deadEnds.length - 1);
                    let pos = deadEnds.splice(idx, 1)[0];
                    const randomPowerUp = this.getRandomPowerUp();
                    chosen.push({ powerUp: randomPowerUp, x: pos.x, y: pos.y });
                }
                this.placedPowerUps = chosen;
                this.emit('powerUpsPlaced', this.placedPowerUps);
            }

            // Get a random power-up by wieghted probability
            getRandomPowerUp() {
                let totalProb = this.powerUps.reduce((sum, p) => sum + p.probability, 0);
                let rand = Math.random() * totalProb;
                for (const p of this.powerUps) {
                    if (rand < p.probability) {
                        return p;
                    }
                    rand -= p.probability;
                }
                return null;
            }

            // --- Utility Functions ---
            randInt(a, b) {
                return Math.floor(Math.random() * (b - a + 1)) + a;
            }

            findDeadEnds() {
                let deadEnds = [];
                for (let y = 1; y < this.mapSize - 1; y++) {
                    for (let x = 1; x < this.mapSize - 1; x++) {
                        if (this.maze[y][x].wall === false && !(x === this.player.x && y === this.player.y) && !(x === this.exit.x && y === this.exit.y)) {
                            let open = 0;
                            if (this.maze[y - 1][x].wall === false) open++;
                            if (this.maze[y + 1][x].wall === false) open++;
                            if (this.maze[y][x - 1].wall === false) open++;
                            if (this.maze[y][x + 1].wall === false) open++;
                            if (open === 1) deadEnds.push({ x, y });
                        }
                    }
                }
                return deadEnds;
            }

            findShortestPath(sx, sy, ex, ey) {
                let queue = [{ x: sx, y: sy, path: [] }];
                let visited = Array(this.mapSize).fill().map(() => Array(this.mapSize).fill(false));
                visited[sy][sx] = true;
                while (queue.length > 0) {
                    let { x, y, path } = queue.shift();
                    if (x === ex && y === ey) return [...path, { x, y }];
                    for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
                        let nx = x + dx, ny = y + dy;
                        if (nx >= 0 && ny >= 0 && nx < this.mapSize && ny < this.mapSize && !visited[ny][nx] && this.maze[ny][nx].wall === false) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny, path: [...path, { x, y }] });
                        }
                    }
                }
                return null;
            }

            isMazeFullyReachable() {
                // BFS from player, do not go through exit
                let visited = Array(this.mapSize).fill().map(() => Array(this.mapSize).fill(false));
                let queue = [];
                queue.push({ x: this.player.x, y: this.player.y });
                visited[this.player.y][this.player.x] = true;
                while (queue.length > 0) {
                    let { x, y } = queue.shift();
                    for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
                        let nx = x + dx, ny = y + dy;
                        if (nx >= 0 && ny >= 0 && nx < this.mapSize && ny < this.mapSize && !visited[ny][nx]) {
                            if (this.maze[ny][nx].wall === false && !(nx === this.exit.x && ny === this.exit.y)) {
                                visited[ny][nx] = true;
                                queue.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
                // Check all non-wall, non-exit cells are visited
                for (let y = 0; y < this.mapSize; y++) {
                    for (let x = 0; x < this.mapSize; x++) {
                        if (this.maze[y][x].wall === false && !(x === this.exit.x && y === this.exit.y)) {
                            if (!visited[y][x]) return false;
                        }
                    }
                }
                return true;
            }
        }

        class Renderer {
            constructor(gameRef, ctxRef, canvasRef) {
                this.game = gameRef;
                this.ctx = ctxRef;
                this.canvas = canvasRef;
                this.guidePath = null;
                this.guideStep = 0;
                this.guideActive = false;
                // subscribe to events
                this.game.on('stateUpdated', () => this.render());
                this.game.on('gameStarted', () => this.render());
                this.game.on('gameEnded', () => this.renderFull());
                this.game.on('visibilityUpdated', () => this.render());
                this.game.on('powerUpsPlaced', () => this.render());
                // when showPath power-up is activated, compute and animate guide
                this.game.on('showPathActivated', ({ x, y }) => {
                    const path = this.game.findShortestPath(x, y, this.game.exit.x, this.game.exit.y);
                    if (path && path.length) {
                        this.setGuide(path);
                    }
                });
            }

            render() {
                const state = this.game.getState();
                if (state.revealMap) return this.renderMaze('full');
                if (state.showFullMapActive) return this.renderMaze('full');
                if (state.followLocationActive) return this.renderMaze('followLocation');
                return this.renderMaze('normal');
            }

            renderFull() { this.renderMaze('full'); }

            renderMaze(mode = 'normal') {
                const { mapSize, maze, player, exit, placedPowerUps, powerUpFogActive, powerUpMarkVisitedActive, revealMap, visibleTiles } = this.game.getState();
                const ctx = this.ctx, canvas = this.canvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                let tileSize, offsetX, offsetY, startX, startY, endX, endY;
                let px = player.x, py = player.y;
                let half = Math.floor(VISIBLE_SIZE / 2);
                let vx = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, px - half));
                let vy = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, py - half));
                if (mode === 'full' || mode === 'followLocation') {
                    tileSize = Math.min((canvas.width - 10) / mapSize, (canvas.height - 10) / mapSize);
                    offsetX = (canvas.width - tileSize * mapSize) / 2;
                    offsetY = (canvas.height - tileSize * mapSize) / 2;
                    startX = 0; startY = 0; endX = mapSize; endY = mapSize;
                } else {
                    tileSize = TILE_SIZE;
                    vx = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, px - half));
                    vy = Math.max(0, Math.min(mapSize - VISIBLE_SIZE, py - half));
                    offsetX = (canvas.width - VISIBLE_SIZE * tileSize) / 2;
                    offsetY = (canvas.height - VISIBLE_SIZE * tileSize) / 2;
                    startX = vx; startY = vy; endX = vx + VISIBLE_SIZE; endY = vy + VISIBLE_SIZE;
                }
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        let tile = maze[y]?.[x] ?? { wall: true };
                        let sx = offsetX + (x - startX) * tileSize;
                        let sy = offsetY + (y - startY) * tileSize;
                        let inViewport = true;
                        if (mode === 'followLocation') {
                            inViewport = x >= vx && x < vx + VISIBLE_SIZE && y >= vy && y < vy + VISIBLE_SIZE;
                            if (!inViewport) {
                                ctx.fillStyle = '#111';
                                ctx.fillRect(sx, sy, tileSize, tileSize);
                                continue;
                            }
                        }
                        if (mode === 'normal' && powerUpFogActive && !tile.visited) {
                            ctx.fillStyle = '#111';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                            continue;
                        }
                        if (mode === 'normal' && !powerUpFogActive && !revealMap && !visibleTiles.has(`${x},${y}`)) {
                            ctx.fillStyle = '#111';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                            continue;
                        }
                        if (exit && x === exit.x && y === exit.y) {
                            ctx.fillStyle = '#ffd700';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                        } else if (tile.wall === true) {
                            ctx.fillStyle = '#444';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                        } else if (powerUpMarkVisitedActive && tile.visited) {
                            // Only highlight visited/explored tiles if the Mark Visited power-up is active
                            ctx.fillStyle = '#b7e4c7';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                        } else if (tile.wall === false) {
                            ctx.fillStyle = '#eee';
                            ctx.fillRect(sx, sy, tileSize, tileSize);
                        }
                        for (const p of placedPowerUps) {
                            if (p.x === x && p.y === y) {
                                ctx.fillStyle = p.powerUp.color;
                                ctx.beginPath();
                                ctx.arc(sx + tileSize / 2, sy + tileSize / 2, tileSize / 3, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        if (x === player.x && y === player.y) {
                            ctx.fillStyle = '#00f';
                            ctx.beginPath();
                            ctx.arc(sx + tileSize / 2, sy + tileSize / 2, tileSize / 2.2, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                }
                // Draw guide overlay after base grid to avoid per-tile checks
                if (this.guideActive && this.guidePath && this.guideStep > 0) {
                    ctx.fillStyle = '#00ffea';
                    for (let i = 0; i < this.guideStep; i++) {
                        const gp = this.guidePath[i];
                        // Skip if outside current render window
                        if (mode === 'full') {
                            const gx = gp.x - startX;
                            const gy = gp.y - startY;
                            if (gx < 0 || gy < 0 || gx >= (endX - startX) || gy >= (endY - startY)) continue;
                            const sx2 = offsetX + gx * tileSize;
                            const sy2 = offsetY + gy * tileSize;
                            ctx.fillRect(sx2 + tileSize / 4, sy2 + tileSize / 4, tileSize / 2, tileSize / 2);
                        } else if (mode === 'followLocation') {
                            // In followLocation, only draw path tiles that are inside the 9x9 viewport around the player
                            const isVisible = gp.x >= vx && gp.x < vx + VISIBLE_SIZE && gp.y >= vy && gp.y < vy + VISIBLE_SIZE;
                            if (!isVisible) continue;
                            const gx = gp.x - startX;
                            const gy = gp.y - startY;
                            const sx2 = offsetX + gx * tileSize;
                            const sy2 = offsetY + gy * tileSize;
                            ctx.fillRect(sx2 + tileSize / 4, sy2 + tileSize / 4, tileSize / 2, tileSize / 2);
                        } else {
                            const gx = gp.x - startX;
                            const gy = gp.y - startY;
                            if (gx < 0 || gy < 0 || gx >= VISIBLE_SIZE || gy >= VISIBLE_SIZE) continue;
                            // Respect darkness rules in normal mode
                            const tile = maze[gp.y]?.[gp.x];
                            const isDark = (powerUpFogActive && (!tile || tile.explored !== true)) || (!powerUpFogActive && !revealMap && !visibleTiles.has(`${gp.x},${gp.y}`));
                            if (isDark) continue;
                            const sx2 = offsetX + gx * tileSize;
                            const sy2 = offsetY + gy * tileSize;
                            ctx.fillRect(sx2 + tileSize / 4, sy2 + tileSize / 4, tileSize / 2, tileSize / 2);
                        }
                    }
                }
            }

            // Guide animation hooks (time-based, constant speed)
            setGuide(path) {
                this.guidePath = path;
                this.guideStep = 0;
                this.guideActive = true;
                this._guideStartTs = performance.now();
                this._guideLastTs = this._guideStartTs;
                this._perStepMs = 50; // 20 steps per second constant speed
                this._runGuideRaf = true;
                this._guideRaf();
            }
            _guideRaf() {
                if (!this._runGuideRaf) return;
                const now = performance.now();
                // Advance steps based on elapsed time for constant speed
                const elapsed = now - this._guideLastTs;
                const advance = Math.floor(elapsed / this._perStepMs);
                if (advance > 0) {
                    this.guideStep = Math.min((this.guideStep || 0) + advance, this.guidePath ? this.guidePath.length : 0);
                    this._guideLastTs += advance * this._perStepMs;
                }
                // Render current frame
                this.render();
                // Stop when finished
                if (!this.guideActive || !this.guidePath || this.guideStep >= this.guidePath.length) {
                    this.guideActive = false;
                    this.guidePath = null;
                    this._runGuideRaf = false;
                    this.render();
                    return;
                }
                requestAnimationFrame(() => this._guideRaf());
            }
        }

        // UI Controller for sidebar updates
        class UIController {
            constructor(gameRef) {
                this.game = gameRef;
                // DOM Elements
                this.scoreEl = document.getElementById('score');
                this.stepsEl = document.getElementById('steps');
                this.timerEl = document.getElementById('timer');
                this.inventoryEl = document.getElementById('inventory');
                this.helpBtn = document.getElementById('help-btn');
                this.helpModal = document.getElementById('help-modal');
                this.closeHelpBtn = document.getElementById('close-help');
                this.mapSizeSelect = document.getElementById('map-size-select');
                this.startBtn = document.getElementById('start-btn');
                this.endgameModal = document.getElementById('endgame-modal');
                this.endgameTitle = document.getElementById('endgame-title');
                this.endgameDetails = document.getElementById('endgame-details');
                this.closeEndgameBtn = document.getElementById('close-endgame');
                // Info modal for power-ups
                this.infoModal = document.getElementById('info-modal');
                this.infoTitle = document.getElementById('info-title');
                this.infoContent = document.getElementById('info-content');
                this.closeInfoBtn = document.getElementById('close-info');
                // Toast elements
                this.toast = document.getElementById('toast');
                this.toastText = document.getElementById('toast-text');
                this.onGameStarted = this.onGameStarted.bind(this);
                this.onStateUpdated = this.onStateUpdated.bind(this);
                this.onTimerUpdated = this.onTimerUpdated.bind(this);
                this.onGameEnded = this.onGameEnded.bind(this);
                this.register();
                this.wireControls();
            }
            register() {
                this.game.on('gameStarted', this.onGameStarted);
                this.game.on('stateUpdated', this.onStateUpdated);
                this.game.on('timerUpdated', this.onTimerUpdated);
                this.game.on('gameEnded', this.onGameEnded);
                this.game.on('revealMapActivated', () => this.onRevealMapActivated());
                this.game.on('powerUpCollected', (powerup) => this.onPowerUpCollected(powerup));
            }
            wireControls() {
                this.startBtn.addEventListener('click', () => {
                    const size = parseInt(this.mapSizeSelect.value, 10);
                    this.game.startGame(size);
                });
                this.helpBtn.addEventListener('click', () => {
                    this.helpModal.style.display = 'flex';
                });
                this.closeHelpBtn.addEventListener('click', () => {
                    this.helpModal.style.display = 'none';
                });
                this.closeEndgameBtn.addEventListener('click', () => {
                    this.endgameModal.style.display = 'none';
                });
                this.closeInfoBtn.addEventListener('click', () => {
                    this.infoModal.style.display = 'none';
                });
            }
            onGameStarted() {
                const s = this.game.getState();
                this.scoreEl.textContent = s.score;
                this.stepsEl.textContent = s.steps;
                this.timerEl.textContent = s.timer;
                this.inventoryEl.textContent = 'None';
                renderer.render();
            }
            onStateUpdated() {
                const s = this.game.getState();
                this.scoreEl.textContent = s.score;
                this.stepsEl.textContent = s.steps;
                renderer.render();
            }
            onTimerUpdated(t) { this.timerEl.textContent = t; }
            onGameEnded(payload) {
                // Update rendering to full view
                renderer.renderFull();
                // Show endgame modal with details
                const { won, score, timer } = payload || {};
                this.endgameTitle.textContent = won ? 'You Escaped the Maze!' : 'Game Over';
                this.endgameDetails.innerHTML = won ? `<p>Score: <b>${score}</b></p><p>Time: <b>${timer}s</b></p>` : '';
                this.endgameModal.style.display = 'flex';
            }
            onRevealMapActivated() {
                // Show info dialog explaining temporary reveal behavior
                this.infoTitle.textContent = 'Reveal Map Activated';
                this.infoContent.innerHTML = '<p>The entire maze is visible now.</p><p>After your next move, visibility will return to the previous state.</p>';
                this.infoModal.style.display = 'flex';
            }
            onPowerUpCollected(powerup) {
                const msg = powerup.description || 'Power-up activated!';
                this.showToast(msg);
            }
            showToast(text) {
                if (!this.toast || !this.toastText) return;
                this.toastText.textContent = text;
                this.toast.style.display = 'block';
                // force reflow for transition
                void this.toast.offsetWidth;
                this.toast.style.opacity = '1';
                // fade out after 2.5s
                clearTimeout(this.toastTimer);
                this.toastTimer = setTimeout(() => {
                    this.toast.style.opacity = '0';
                    setTimeout(() => {
                        this.toast.style.display = 'none';
                    }, 600);
                }, 2500);
            }
            startInitialGame() {
                const size = parseInt(this.mapSizeSelect.value, 10);
                this.game.startGame(size);
            }
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            resizeCanvas();
            renderer.render();
        });

        document.addEventListener('keydown', e => {
            if (!game.gameStarted) return;
            if (game.isSliding) return; // ignore input during sliding animation
            const slide = e.shiftKey === true;
            if (e.key === 'ArrowUp' || e.key === 'w') slide ? game.slideMove(0, -1) : game.movePlayer(0, -1);
            if (e.key === 'ArrowDown' || e.key === 's') slide ? game.slideMove(0, 1) : game.movePlayer(0, 1);
            if (e.key === 'ArrowLeft' || e.key === 'a') slide ? game.slideMove(-1, 0) : game.movePlayer(-1, 0);
            if (e.key === 'ArrowRight' || e.key === 'd') slide ? game.slideMove(1, 0) : game.movePlayer(1, 0);
        });

        // --- Canvas Elements ---
        const canvas = document.getElementById('maze-canvas');
        const ctx = canvas.getContext('2d');

        // -- Helpers ---
        function resizeCanvas() {
            // Set both CSS and element attributes for canvas size
            const w = window.innerWidth - 320;
            const h = window.innerHeight;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            canvas.width = w;
            canvas.height = h;
        }

        const TILE_SIZE = 32; // default tile size 32x32
        const VISIBLE_SIZE = 9; // default visible window 9x9

        // -- Game Initialization ---
        const game = new SuperMazeGame();
        const renderer = new Renderer(game, ctx, canvas);
        const ui = new UIController(game);

        window.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            ui.startInitialGame();
        });
    </script>
</body>

</html>