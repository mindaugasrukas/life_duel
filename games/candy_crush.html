<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candy Crush</title>
    <style>
        #gameover-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #gameover-modal > div {
            background: #333;
            color: #ffd700;
            padding: 32px;
            border-radius: 12px;
            max-width: 400px;
            box-shadow: 0 0 24px #000;
            text-align: center;
        }
        #close-gameover {
            margin-top: 24px;
            background: #444;
            color: #ffd700;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }
        .candy.invalid-swap {
            animation: swap-back 0.4s;
            box-shadow: 0 0 8px 2px #f44336;
            background: #f44336;
            color: #fff;
        }
        @keyframes swap-back {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2) translateY(-8px); opacity: 0.7; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .candy.matched {
            animation: match-pop 0.4s;
            box-shadow: 0 0 16px 6px #ffd700, 0 0 32px 12px #ff9800;
            background: #ffd700;
            color: #222;
        }
        @keyframes match-pop {
            0% { transform: scale(1); opacity: 1; }
            60% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(0.7); opacity: 0.2; }
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
        }
        #game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        #candy-area {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100vw - 320px);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .candy-grid {
            display: grid;
            grid-template-columns: repeat(8, 48px);
            grid-template-rows: repeat(8, 48px);
            gap: 6px;
            background: #181818;
            border-radius: 12px;
            box-shadow: 0 2px 12px #111;
            padding: 24px;
        }
        .candy {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            background: #333;
        }
        .candy.selected {
            box-shadow: 0 0 0 4px #ff9800;
        }
        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #2a2a2a;
            padding: 32px 18px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            border-left: 2px solid #444;
            z-index: 10;
        }
        #sidebar h2 {
            margin-top: 0;
            font-size: 1.4em;
            color: #ffd700;
        }
        .score, .moves {
            margin-bottom: 18px;
            font-size: 1.1em;
        }
        .game-buttons {
            margin-bottom: 18px;
        }
        .game-buttons button {
            background: #ffd700;
            color: #222;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            font-size: 1.1em;
            cursor: pointer;
        }
        .instructions {
            margin-top: 18px;
            color: #eee;
            font-size: 1em;
        }
        .home-link {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            text-decoration: none;
            color: #fff;
            font-size: 1.1em;
        }
        .home-link svg {
            margin-right: 8px;
        }
        .candy.falling {
            animation: candy-fall 0.4s cubic-bezier(.4,2,.6,1) forwards;
            z-index: 2;
        }
        @keyframes candy-fall {
            0% { transform: translateY(-60px) scale(1.1); opacity: 0.2; }
            80% { transform: translateY(0) scale(1.05); opacity: 1; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="candy-area">
            <div class="candy-grid" id="candyGrid"></div>
        </div>
        <div id="sidebar">
            <a href="../index.html" title="Back to Home" class="home-link">
                <svg width="28" height="28" viewBox="0 0 24 24">
                    <path d="M15 18l-6-6 6-6" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Home</span>
            </a>
            <h2>Candy Crush</h2>
            <div class="score">Score: <span id="score">0</span></div>
            <div class="moves">Moves: <span id="moves">20</span></div>
            <div class="game-buttons">
                <button onclick="restartGame()">Restart</button>
            </div>
            <div class="instructions">
                <strong>How to play:</strong><br>
                Swap adjacent candies to make lines of 3 or more matching candies. Matches disappear, candies fall down, and new candies appear. Reach the highest score in 20 moves!
            </div>
        </div>
    </div>
    <div id="gameover-modal">
        <div>
            <h3>Game Over</h3>
            <div id="gameover-reason"></div>
            <div style="margin-top:12px;font-size:1.1em;">Final Score: <span id="final-score">0</span></div>
            <button id="close-gameover" onclick="restartGame()">Restart</button>
        </div>
    </div>
    <script>
const bgMusicList = [
    'sounds/mixkit-sweet-september-282.mp3',
    'sounds/mixkit-harp-relax-669.mp3',
    'sounds/mixkit-rebel-wayz-232.mp3',
    'sounds/mixkit-relaxation-02-746.mp3',
    'sounds/mixkit-relaxation-03-747.mp3',
    'sounds/mixkit-relaxation-04-750.mp3',
    // 'sounds/video-game-loop-2-390279.mp3',
    // 'sounds/mixkit-relax-658.mp3',
    // 'sounds/keys-of-moon-under-the-sun.mp3',
    // 'sounds/game-music-loop-4-144341.mp3',
    // 'sounds/epic-chase.mp3',
    // 'sounds/mixkit-lo-fi-02-764.mp3',
    // 'sounds/mixkit-relaxation-06-748.mp3',
];
const soundInvalidMatch = 'sounds/mixkit-interface-option-select-2573.wav';
const soundMatch = 'sounds/mixkit-video-game-treasure-2066.wav';
const soundGameover = 'sounds/mixkit-wrong-answer-fail-notification-946.wav';
const soundNew = 'sounds/fall-394469.mp3';

function pickRandomMusic() {
    return bgMusicList[Math.floor(Math.random() * bgMusicList.length)];
}
function setBgMusic(trackUrl) {
    let music = document.getElementById('bg-music');
    if (!music) {
        music = document.createElement('audio');
        music.id = 'bg-music';
        music.loop = true;
        music.autoplay = true;
        document.body.insertBefore(music, document.body.firstChild);
    }
    music.src = trackUrl;
    music.load();
    music.play().catch(()=>{});
}
// On page load, pick and play a random track
setBgMusic(pickRandomMusic());
// On restart, pick a new track
const origRestartGame = window.restartGame;
window.restartGame = function() {
    setBgMusic(pickRandomMusic());
    origRestartGame && origRestartGame();
};
        function hasPossibleMoves() {
            // Check for any possible swap that would result in a match
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    // Try swapping right
                    if (c < gridSize - 1) {
                        swapCandies(r, c, r, c+1);
                        if (checkMatchAt(r, c) || checkMatchAt(r, c+1)) {
                            swapCandies(r, c, r, c+1); // revert
                            return true;
                        }
                        swapCandies(r, c, r, c+1); // revert
                    }
                    // Try swapping down
                    if (r < gridSize - 1) {
                        swapCandies(r, c, r+1, c);
                        if (checkMatchAt(r, c) || checkMatchAt(r+1, c)) {
                            swapCandies(r, c, r+1, c); // revert
                            return true;
                        }
                        swapCandies(r, c, r+1, c); // revert
                    }
                }
            }
            return false;
        }

        function checkMatchAt(r, c) {
            const candy = grid[r][c];
            // Horizontal
            let count = 1;
            for (let i = c-1; i >= 0 && grid[r][i] === candy; i--) count++;
            for (let i = c+1; i < gridSize && grid[r][i] === candy; i++) count++;
            if (count >= 3) return true;
            // Vertical
            count = 1;
            for (let i = r-1; i >= 0 && grid[i][c] === candy; i--) count++;
            for (let i = r+1; i < gridSize && grid[i][c] === candy; i++) count++;
            if (count >= 3) return true;
            return false;
        }
        const gridSize = 8;
        const candyTypes = ['üçí', 'üçã', 'üçá', 'üç¨', 'üç´', 'üçä'];
        let grid = [];
        let score = 0;
        let moves = 20;
        let selected = null;

        function randomCandy() {
            return candyTypes[Math.floor(Math.random() * candyTypes.length)];
        }

        function createGrid() {
            grid = [];
            for (let r = 0; r < gridSize; r++) {
                let row = [];
                for (let c = 0; c < gridSize; c++) {
                    row.push(randomCandy());
                }
                grid.push(row);
            }
        }

        function renderGrid(matchedMap, fallingMap) {
            const gridDiv = document.getElementById('candyGrid');
            gridDiv.innerHTML = '';
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const candyDiv = document.createElement('div');
                    let classes = 'candy';
                    if (selected && selected.r === r && selected.c === c) classes += ' selected';
                    if (matchedMap && matchedMap[r][c]) classes += ' matched';
                    if (fallingMap && fallingMap[r][c]) classes += ' falling';
                    if (window.invalidSwap && ((r === window.invalidSwap.r1 && c === window.invalidSwap.c1) || (r === window.invalidSwap.r2 && c === window.invalidSwap.c2))) {
                        classes += ' invalid-swap';
                    }
                    candyDiv.className = classes;
                    candyDiv.textContent = grid[r][c];
                    candyDiv.onclick = () => selectCandy(r, c);
                    gridDiv.appendChild(candyDiv);
                }
            }
            document.getElementById('score').textContent = score;
            document.getElementById('moves').textContent = moves;
            // Show end game modal if no moves left or no possible moves
            setTimeout(() => {
                let reason = '';
                if (moves <= 0) {
                    reason = 'Out of moves!';
                } else if (!hasPossibleMoves()) {
                    reason = 'No more possible moves!';
                }
                if (reason) {
                    document.getElementById('gameover-modal').style.display = 'flex';
                    document.getElementById('gameover-reason').textContent = reason;
                    document.getElementById('final-score').textContent = score;
                    playSound(soundGameover, false);
                }
            }, 10);
        }

        function selectCandy(r, c) {
            if (moves <= 0) return;
            if (!selected) {
                selected = { r, c };
                renderGrid();
            } else if (selected.r === r && selected.c === c) {
                // Deselect if clicking the same candy
                selected = null;
                renderGrid();
            } else {
                // Only allow adjacent swap
                if ((Math.abs(selected.r - r) + Math.abs(selected.c - c)) === 1) {
                    swapCandies(selected.r, selected.c, r, c);
                    let matchInfo = getMatchedMap();
                    let matched = 0;
                    for (let rr = 0; rr < gridSize; rr++) {
                        for (let cc = 0; cc < gridSize; cc++) {
                            if (matchInfo[rr][cc]) matched++;
                        }
                    }
                    if (matched > 0) {
                            moves--;
                            selected = null;
                            setTimeout(() => {
                                playSound(soundMatch);
                            }, 200);
                            // Step 1: show normal grid
                            renderGrid();
                            // Step 2: show match animation only
                            setTimeout(() => {
                                renderGrid(matchInfo);
                                // Step 3: clear matches and show falling animation only
                                setTimeout(() => {
                                    findAndClearMatches();
                                    score += matched * 10;
                                    // refillGrid will show falling animation, then normal grid
                                    refillGrid();
                                }, 400);
                            }, 200); // increase delay to ensure match animation is visible
                    } else {
                        // No match, animate swap back
                        window.invalidSwap = { r1: selected.r, c1: selected.c, r2: r, c2: c };
                        selected = null;
                        setTimeout(() => {
                            playSound(soundInvalidMatch);
                        }, 10);
                        renderGrid();
                        setTimeout(() => {
                            swapCandies(window.invalidSwap.r1, window.invalidSwap.c1, window.invalidSwap.r2, window.invalidSwap.c2);
                            window.invalidSwap = null;
                            renderGrid();
                        }, 400);
                    }
                } else {
                    selected = { r, c };
                    renderGrid();
                }
        // Returns a map of matched candies for visual effect
        function getMatchedMap() {
            let matchedMap = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            // Horizontal
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize - 2; c++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r][c+1] && candy === grid[r][c+2]) {
                        matchedMap[r][c] = matchedMap[r][c+1] = matchedMap[r][c+2] = true;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < gridSize; c++) {
                for (let r = 0; r < gridSize - 2; r++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r+1][c] && candy === grid[r+2][c]) {
                        matchedMap[r][c] = matchedMap[r+1][c] = matchedMap[r+2][c] = true;
                    }
                }
            }
            return matchedMap;
        }
            }
        }
        function swapCandies(r1, c1, r2, c2) {
            let temp = grid[r1][c1];
            grid[r1][c1] = grid[r2][c2];
            grid[r2][c2] = temp;
        }

        function findAndClearMatches() {
            let matched = 0;
            let toClear = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            // Horizontal
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize - 2; c++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r][c+1] && candy === grid[r][c+2]) {
                        toClear[r][c] = toClear[r][c+1] = toClear[r][c+2] = true;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < gridSize; c++) {
                for (let r = 0; r < gridSize - 2; r++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r+1][c] && candy === grid[r+2][c]) {
                        toClear[r][c] = toClear[r+1][c] = toClear[r+2][c] = true;
                    }
                }
            }
            // Clear matches
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (toClear[r][c]) {
                        grid[r][c] = null;
                        matched++;
                    }
                }
            }
            return matched;
        }

        function playSound(sound, checkMuted = true) {
            const snd = new Audio(sound);
            if (checkMuted) {
                snd.volume = document.getElementById('bg-music')?.muted ? 0 : 1;
            }
            snd.play();
        }

        function refillGrid() {
            let newCandyCount = 0;
            let fallingMap = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            for (let c = 0; c < gridSize; c++) {
                for (let r = gridSize - 1; r >= 0; r--) {
                    if (!grid[r][c]) {
                        // Move candies down
                        let rr = r - 1;
                        while (rr >= 0 && !grid[rr][c]) rr--;
                        if (rr >= 0) {
                            grid[r][c] = grid[rr][c];
                            grid[rr][c] = null;
                        } else {
                            grid[r][c] = randomCandy();
                            newCandyCount++;
                            fallingMap[r][c] = true;
                            setTimeout(() => {
                                playSound(soundNew);
                            }, newCandyCount * 40); // stagger sounds for effect
                        }
                    }
                }
            }
            renderGrid(undefined, fallingMap);
            setTimeout(() => {
                // Check for new matches
                let matched = findAndClearMatches();
                if (matched > 0) {
                    score += matched * 10;
                    refillGrid();
                } else {
                    renderGrid();
                }
            }, 500);
        }

        function restartGame() {
            document.getElementById('gameover-modal').style.display = 'none';
            score = 0;
            moves = 20;
            selected = null;
            createGrid();
            // Remove any initial matches
            let initialMatched;
            do {
                initialMatched = findAndClearMatches();
                if (initialMatched > 0) refillGrid();
            } while (initialMatched > 0);
            renderGrid();
        }

        // Initialize
        createGrid();
        // Remove any initial matches
        let initialMatched;
        do {
            initialMatched = findAndClearMatches();
            if (initialMatched > 0) refillGrid();
        } while (initialMatched > 0);
        renderGrid();
        // Add mute/unmute button to sidebar
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
            const musicBtn = document.createElement('button');
            musicBtn.textContent = 'üîä Music';
            musicBtn.style.marginBottom = '12px';
            musicBtn.style.background = '#444';
            musicBtn.style.color = '#ffd700';
            musicBtn.style.border = 'none';
            musicBtn.style.borderRadius = '6px';
            musicBtn.style.padding = '8px 18px';
            musicBtn.style.fontSize = '1em';
            musicBtn.style.cursor = 'pointer';
            let muted = false;
            musicBtn.onclick = function() {
                const music = document.getElementById('bg-music');
                muted = !muted;
                music.muted = muted;
                musicBtn.textContent = muted ? 'üîá Music' : 'üîä Music';
                if (!music.paused) return;
                music.play().catch(()=>{});
            };
            sidebar.insertBefore(musicBtn, sidebar.firstChild.nextSibling);
            // Try to play music on load (may require user interaction)
            setTimeout(() => {
                const music = document.getElementById('bg-music');
                music.play().catch(() => {
                    // If autoplay fails, show Play Music button
                    let playBtn = document.getElementById('play-music-btn');
                    if (!playBtn) {
                        playBtn = document.createElement('button');
                        playBtn.id = 'play-music-btn';
                        playBtn.textContent = '‚ñ∂Ô∏è Play Music';
                        playBtn.style.background = '#ffd700';
                        playBtn.style.color = '#222';
                        playBtn.style.border = 'none';
                        playBtn.style.borderRadius = '6px';
                        playBtn.style.padding = '8px 18px';
                        playBtn.style.fontSize = '1em';
                        playBtn.style.cursor = 'pointer';
                        playBtn.onclick = function() {
                            music.play().then(() => {
                                playBtn.remove();
                            }).catch(()=>{});
                        };
                        sidebar.insertBefore(playBtn, musicBtn.nextSibling);
                    }
                });
            }, 500);
        }
        setTimeout(() => {
            document.getElementById('bg-music').muted = false;
        }, 500);
    </script>
</body>
</html>
