<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candy Crush</title>
    <style>
        #gameover-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #gameover-modal > div {
            background: #333;
            color: #ffd700;
            padding: 32px;
            border-radius: 12px;
            max-width: 400px;
            box-shadow: 0 0 24px #000;
            text-align: center;
        }
        #close-gameover {
            margin-top: 24px;
            background: #444;
            color: #ffd700;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }
        .candy.invalid-swap {
            animation: swap-back 0.4s;
            box-shadow: 0 0 8px 2px #f44336;
            background: #f44336;
            color: #fff;
        }
        @keyframes swap-back {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2) translateY(-8px); opacity: 0.7; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .candy.matched {
            animation: match-pop 0.4s;
            box-shadow: 0 0 16px 6px #ffd700, 0 0 32px 12px #ff9800;
            background: #ffd700;
            color: #222;
        }
        .candy.bomb-exploding {
            animation: bomb-explode 0.5s cubic-bezier(.7,-0.2,.7,1.5);
            box-shadow: 0 0 32px 12px #ff5252, 0 0 64px 24px #fff;
            background: #ff5252 !important;
            color: #fff !important;
            z-index: 10;
        }
        @keyframes bomb-explode {
            0% { transform: scale(1); opacity: 1; }
            30% { transform: scale(1.3) rotate(-8deg); opacity: 1; }
            60% { transform: scale(1.5) rotate(8deg); opacity: 0.8; }
            100% { transform: scale(0.7); opacity: 0.1; }
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
        }
        #game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        #candy-area {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100vw - 320px);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .candy-grid {
            display: grid;
            grid-template-columns: repeat(8, 48px);
            grid-template-rows: repeat(8, 48px);
            gap: 6px;
            background: #181818;
            border-radius: 12px;
            box-shadow: 0 2px 12px #111;
            padding: 24px;
        }
        .candy {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            background: #333;
        }
        .candy.selected {
            box-shadow: 0 0 0 4px #ff9800;
        }
        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: #2a2a2a;
            padding: 32px 18px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            border-left: 2px solid #444;
            z-index: 10;
        }
        #sidebar h2 {
            margin-top: 0;
            font-size: 1.4em;
            color: #ffd700;
        }
        .score, .moves {
            margin-bottom: 18px;
            font-size: 1.1em;
        }
        .game-buttons {
            margin-bottom: 18px;
        }
        .game-buttons button {
            background: #444;
            color: #ffd700;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            margin: 6px 0;
            font-size: 1em;
            cursor: pointer;
        }
        .instructions {
            margin-top: 18px;
            color: #eee;
            font-size: 1em;
        }
        .home-link {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            text-decoration: none;
            color: #fff;
            font-size: 1.1em;
        }
        .home-link svg {
            margin-right: 8px;
        }
        .candy.falling {
            animation: candy-fall 0.4s cubic-bezier(.4,2,.6,1) forwards;
            z-index: 2;
        }
        @keyframes candy-fall {
            0% { transform: translateY(-60px) scale(1.1); opacity: 0.2; }
            80% { transform: translateY(0) scale(1.05); opacity: 1; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="candy-area">
            <div class="candy-grid" id="candyGrid"></div>
        </div>
        <div id="sidebar">
            <a href="../index.html" title="Back to Home" class="home-link">
                <svg width="28" height="28" viewBox="0 0 24 24">
                    <path d="M15 18l-6-6 6-6" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Home</span>
            </a>
            <h2>Candy Crush</h2>
            <div class="score">Score: <span id="score">0</span></div>
            <div class="target-score">Target: <span id="target-score">1000</span></div>
            <div class="moves">Moves: <span id="moves">20</span></div>
            <div class="game-buttons">
                <button onclick="restartGame()">Restart</button><br />
                <button onclick="setBgMusic(pickRandomMusic())"> Change Music</button><br />
                <button onclick="toggleMusic()" id="toggle-music-btn">🔊 Music</button><br />
                <button onclick="toggleSoundEffects()" id="toggle-sound-effects-btn">🔊 Sound Effects</button><br />
            </div>
            <div class="instructions">
                <strong>How to play:</strong><br>
                Swap adjacent candies to make lines of 3 or more matching candies. Matches disappear, candies fall down, and new candies appear.<br>
                Reach at least <span id="target-score-instr">1000</span> points in 20 moves to win!
            </div>
        </div>
    </div>
    <div id="gameover-modal">
        <div>
            <h3>Game Over</h3>
            <div id="gameover-reason"></div>
            <div style="margin-top:12px;font-size:1.1em;">Final Score: <span id="final-score">0</span></div>
            <button id="close-gameover" onclick="restartGame()">Restart</button>
        </div>
    </div>
    <script>
        const bgMusicList = [
            'sounds/mixkit-sweet-september-282.mp3',
            'sounds/mixkit-harp-relax-669.mp3',
            'sounds/mixkit-rebel-wayz-232.mp3',
            'sounds/mixkit-relaxation-02-746.mp3',
            'sounds/mixkit-relaxation-03-747.mp3',
            'sounds/mixkit-relaxation-04-750.mp3',
            // 'sounds/video-game-loop-2-390279.mp3',
            // 'sounds/mixkit-relax-658.mp3',
            // 'sounds/keys-of-moon-under-the-sun.mp3',
            // 'sounds/game-music-loop-4-144341.mp3',
            // 'sounds/epic-chase.mp3',
            // 'sounds/mixkit-lo-fi-02-764.mp3',
            // 'sounds/mixkit-relaxation-06-748.mp3',
        ];
        const soundInvalidMatch = 'sounds/mixkit-interface-option-select-2573.wav';
        const soundMatch = 'sounds/mixkit-video-game-treasure-2066.wav';
        const soundGameover = 'sounds/mixkit-wrong-answer-fail-notification-946.wav';
        const soundNew = 'sounds/fall-394469.mp3';
        const victorySound = 'sounds/level-complete-394515.mp3';
        let soundEffectsEnabled = true;

        function pickRandomMusic() {
            return bgMusicList[Math.floor(Math.random() * bgMusicList.length)];
        }

        function setBgMusic(trackUrl) {
            let music = document.getElementById('bg-music');
            if (!music) {
                music = document.createElement('audio');
                music.id = 'bg-music';
                music.loop = true;
                music.autoplay = true;
                document.body.insertBefore(music, document.body.firstChild);
            }
            music.src = trackUrl;
            music.load();
            music.play().catch(()=>{});
        }

        // On page load, pick and play a random track
        setBgMusic(pickRandomMusic());
        // On restart, pick a new track
        const origRestartGame = window.restartGame;
        window.restartGame = function() {
            setBgMusic(pickRandomMusic());
            origRestartGame && origRestartGame();
        };

        function hasPossibleMoves() {
            // Check for any possible swap that would result in a match
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    // Try swapping right
                    if (c < gridSize - 1) {
                        swapCandies(r, c, r, c+1);
                        if (checkMatchAt(r, c) || checkMatchAt(r, c+1)) {
                            swapCandies(r, c, r, c+1); // revert
                            return true;
                        }
                        swapCandies(r, c, r, c+1); // revert
                    }
                    // Try swapping down
                    if (r < gridSize - 1) {
                        swapCandies(r, c, r+1, c);
                        if (checkMatchAt(r, c) || checkMatchAt(r+1, c)) {
                            swapCandies(r, c, r+1, c); // revert
                            return true;
                        }
                        swapCandies(r, c, r+1, c); // revert
                    }
                }
            }
            return false;
        }

        function checkMatchAt(r, c) {
            const candy = grid[r][c];
            // Horizontal
            let count = 1;
            for (let i = c-1; i >= 0 && grid[r][i] === candy; i--) count++;
            for (let i = c+1; i < gridSize && grid[r][i] === candy; i++) count++;
            if (count >= 3) return true;
            // Vertical
            count = 1;
            for (let i = r-1; i >= 0 && grid[i][c] === candy; i--) count++;
            for (let i = r+1; i < gridSize && grid[i][c] === candy; i++) count++;
            if (count >= 3) return true;
            return false;
        }

        const gridSize = 8;
        const candyTypes = ['🍒', '🍋', '🍇', '🍬', '🍫', '🍊'];
        const bombCandy = '💣';
        let grid = [];
        let score = 0;
        let moves = 20;
        let selected = null;
        let targetScore = 1000;

        function randomCandy() {
            return candyTypes[Math.floor(Math.random() * candyTypes.length)];
        }

        function createGrid() {
            grid = [];
            for (let r = 0; r < gridSize; r++) {
                let row = [];
                for (let c = 0; c < gridSize; c++) {
                    row.push(randomCandy());
                }
                grid.push(row);
            }
        }

        // bombExplodeMap: optional 2D array, true for candies to animate as bomb explosion
        let gameEnded = false;
        function renderGrid(matchedMap, fallingMap, bombExplodeMap) {
            const gridDiv = document.getElementById('candyGrid');
            gridDiv.innerHTML = '';
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const candyDiv = document.createElement('div');
                    let classes = 'candy';
                    if (selected && selected.r === r && selected.c === c) classes += ' selected';
                    if (matchedMap && matchedMap[r][c]) classes += ' matched';
                    if (fallingMap && fallingMap[r][c]) classes += ' falling';
                    if (bombExplodeMap && bombExplodeMap[r][c]) classes += ' bomb-exploding';
                    if (window.invalidSwap && ((r === window.invalidSwap.r1 && c === window.invalidSwap.c1) || (r === window.invalidSwap.r2 && c === window.invalidSwap.c2))) {
                        classes += ' invalid-swap';
                    }
                    // Bomb special effect
                    if (grid[r][c] === bombCandy) {
                        candyDiv.style.background = '#222';
                        candyDiv.style.color = '#ff5252';
                        candyDiv.style.fontWeight = 'bold';
                        candyDiv.style.textShadow = '0 0 8px #fff, 0 0 16px #ff5252';
                    }
                    candyDiv.className = classes;
                    candyDiv.textContent = grid[r][c];
                    candyDiv.onclick = () => selectCandy(r, c);
                    gridDiv.appendChild(candyDiv);
                }
            }
            // Add touch listeners for tablet play
            addTouchListeners();
            document.getElementById('moves').textContent = moves;
            document.getElementById('target-score').textContent = targetScore;
            let instr = document.getElementById('target-score-instr');
            if (instr) instr.textContent = targetScore;
            // End game immediately if target score is reached
            if (!gameEnded && score >= targetScore) {
                gameEnded = true;
                setTimeout(() => {
                    document.getElementById('gameover-modal').style.display = 'flex';
                    document.getElementById('gameover-reason').textContent = 'Congratulations! You reached the target!';
                    document.getElementById('final-score').textContent = score;
                    playSound(victorySound, false);
                }, 10);
                return;
            }
            // Show end game modal if no moves left or no possible moves
            setTimeout(() => {
                if (gameEnded) return;
                let reason = '';
                if (moves <= 0) {
                    reason = 'Out of moves!';
                } else if (!hasPossibleMoves()) {
                    reason = 'No more possible moves!';
                }
                if (reason) {
                    gameEnded = true;
                    document.getElementById('gameover-modal').style.display = 'flex';
                    document.getElementById('gameover-reason').textContent = reason;
                    document.getElementById('final-score').textContent = score;
                    playSound(soundGameover, false);
                }
            }, 10);
        }

        // Touch swipe support for tablet play
        function addTouchListeners() {
            const gridDiv = document.getElementById('candyGrid');
            let touchStart = null;
            gridDiv.querySelectorAll('.candy').forEach((cell, idx) => {
                cell.addEventListener('touchstart', function(e) {
                    touchStart = e.touches[0];
                    e.preventDefault();
                }, { passive: false });
                cell.addEventListener('touchend', function(e) {
                    if (!touchStart) return;
                    const touchEnd = e.changedTouches[0];
                    const dx = touchEnd.clientX - touchStart.clientX;
                    const dy = touchEnd.clientY - touchStart.clientY;
                    const threshold = 30; // Minimum swipe distance
                    const r = Math.floor(idx / gridSize);
                    const c = idx % gridSize;
                    let r2 = r, c2 = c;
                    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                        // Horizontal swipe
                        if (dx > 0 && c < gridSize - 1) c2 = c + 1; // right
                        else if (dx < 0 && c > 0) c2 = c - 1; // left
                    } else if (Math.abs(dy) > threshold) {
                        // Vertical swipe
                        if (dy > 0 && r < gridSize - 1) r2 = r + 1; // down
                        else if (dy < 0 && r > 0) r2 = r - 1; // up
                    }
                    // Only swap if destination is different
                    if (r !== r2 || c !== c2) {
                        swapCandies(r, c, r2, c2);
                        // After swap, run match logic as if selected
                        let matchInfo = getMatchedMap();
                        let matched = 0;
                        for (let rr = 0; rr < gridSize; rr++) {
                            for (let cc = 0; cc < gridSize; cc++) {
                                if (matchInfo[rr][cc]) matched++;
                            }
                        }
                        if (matched > 0) {
                            moves--;
                            setTimeout(() => { playSound(soundMatch); }, 200);
                            renderGrid();
                            setTimeout(() => {
                                renderGrid(matchInfo);
                                setTimeout(() => {
                                    findAndClearMatches();
                                    updateScore(matched);
                                    refillGrid();
                                }, 400);
                            }, 200);
                        } else {
                            // No match, animate swap back
                            window.invalidSwap = { r1: r, c1: c, r2: r2, c2: c2 };
                            setTimeout(() => { playSound(soundInvalidMatch); }, 10);
                            renderGrid();
                            setTimeout(() => {
                                swapCandies(window.invalidSwap.r1, window.invalidSwap.c1, window.invalidSwap.r2, window.invalidSwap.c2);
                                window.invalidSwap = null;
                                renderGrid();
                            }, 400);
                        }
                    }
                    touchStart = null;
                    e.preventDefault();
                }, { passive: false });
            });
        }

        function explodeBombAt(r, c) {
            // Clear 3x3 area centered on (r, c)
            let toClear = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    let rr = r + dr, cc = c + dc;
                    if (rr >= 0 && rr < gridSize && cc >= 0 && cc < gridSize) {
                        toClear[rr][cc] = true;
                    }
                }
            }
            // Show bomb explosion effect first
            renderGrid(undefined, undefined, toClear);
            playSound(soundMatch);
            setTimeout(() => {
                // Clear and count
                let matched = 0;
                for (let rr = 0; rr < gridSize; rr++) {
                    for (let cc = 0; cc < gridSize; cc++) {
                        if (toClear[rr][cc] && grid[rr][cc]) {
                            grid[rr][cc] = null;
                            matched++;
                        }
                    }
                }
                // Bomb explosion always scores 100
                score += 100;
                renderGrid();
                setTimeout(refillGrid, 400);
            }, 500);
        }

        function explodeWholeBoard() {
            // Mark all cells for explosion effect
            let toClear = Array.from({ length: gridSize }, () => Array(gridSize).fill(true));
            renderGrid(undefined, undefined, toClear);
            playSound(soundMatch);
            setTimeout(() => {
                for (let rr = 0; rr < gridSize; rr++) {
                    for (let cc = 0; cc < gridSize; cc++) {
                        if (grid[rr][cc]) {
                            grid[rr][cc] = null;
                        }
                    }
                }
                // Double bomb swap always scores 1000
                score += 1000;
                renderGrid();
                setTimeout(refillGrid, 400);
            }, 700);
        }

        function selectCandy(r, c) {
            if (moves <= 0) return;
            if (!selected) {
                selected = { r, c };
                renderGrid();
            } else if (selected.r === r && selected.c === c) {
                // Deselect if clicking the same candy
                selected = null;
                renderGrid();
            } else {
                // Only allow adjacent swap
                if ((Math.abs(selected.r - r) + Math.abs(selected.c - c)) === 1) {
                    swapCandies(selected.r, selected.c, r, c);
                    // Bomb swap logic
                    if (grid[r][c] === bombCandy && grid[selected.r][selected.c] === bombCandy) {
                        moves--;
                        selected = null;
                        explodeWholeBoard();
                        return;
                    } else if (grid[r][c] === bombCandy) {
                        moves--;
                        selected = null;
                        explodeBombAt(r, c);
                        return;
                    } else if (grid[selected.r][selected.c] === bombCandy) {
                        moves--;
                        selected = null;
                        explodeBombAt(selected.r, selected.c);
                        return;
                    }
                    let matchInfo = getMatchedMap();
                    let matched = 0;
                    for (let rr = 0; rr < gridSize; rr++) {
                        for (let cc = 0; cc < gridSize; cc++) {
                            if (matchInfo[rr][cc]) matched++;
                        }
                    }
                    if (matched > 0) {
                        moves--;
                        selected = null;
                        setTimeout(() => {
                            playSound(soundMatch);
                        }, 200);
                        // Step 1: show normal grid
                        renderGrid();
                        // Step 2: show match animation only
                        setTimeout(() => {
                            renderGrid(matchInfo);
                            // Step 3: clear matches and show falling animation only
                            setTimeout(() => {
                                findAndClearMatches();
                                updateScore(matched);
                                // refillGrid will show falling animation, then normal grid
                                refillGrid();
                            }, 400);
                        }, 200); // increase delay to ensure match animation is visible
                    } else {
                        // No match, animate swap back
                        window.invalidSwap = { r1: selected.r, c1: selected.c, r2: r, c2: c };
                        selected = null;
                        setTimeout(() => {
                            playSound(soundInvalidMatch);
                        }, 10);
                        renderGrid();
                        setTimeout(() => {
                            swapCandies(window.invalidSwap.r1, window.invalidSwap.c1, window.invalidSwap.r2, window.invalidSwap.c2);
                            window.invalidSwap = null;
                            renderGrid();
                        }, 400);
                    }
                } else {
                    selected = { r, c };
                    renderGrid();
                }
            }
        }

        // Returns a map of matched candies for visual effect, and marks 2x2 bombs
        function getMatchedMap() {
            let matchedMap = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            // Horizontal
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize - 2; c++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r][c+1] && candy === grid[r][c+2]) {
                        matchedMap[r][c] = matchedMap[r][c+1] = matchedMap[r][c+2] = true;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < gridSize; c++) {
                for (let r = 0; r < gridSize - 2; r++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r+1][c] && candy === grid[r+2][c]) {
                        matchedMap[r][c] = matchedMap[r+1][c] = matchedMap[r+2][c] = true;
                    }
                }
            }
            // 2x2 bomb pattern
            for (let r = 0; r < gridSize - 1; r++) {
                for (let c = 0; c < gridSize - 1; c++) {
                    let candy = grid[r][c];
                    if (candy && candy !== bombCandy &&
                        grid[r][c+1] === candy &&
                        grid[r+1][c] === candy &&
                        grid[r+1][c+1] === candy) {
                        // Mark all 2x2 as matched for animation
                        matchedMap[r][c] = matchedMap[r][c+1] = matchedMap[r+1][c] = matchedMap[r+1][c+1] = true;
                    }
                }
            }
            return matchedMap;
        }

        function swapCandies(r1, c1, r2, c2) {
            let temp = grid[r1][c1];
            grid[r1][c1] = grid[r2][c2];
            grid[r2][c2] = temp;
        }

        function findAndClearMatches() {
            let matched = 0;
            let toClear = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            // Horizontal
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize - 2; c++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r][c+1] && candy === grid[r][c+2]) {
                        toClear[r][c] = toClear[r][c+1] = toClear[r][c+2] = true;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < gridSize; c++) {
                for (let r = 0; r < gridSize - 2; r++) {
                    let candy = grid[r][c];
                    if (candy && candy === grid[r+1][c] && candy === grid[r+2][c]) {
                        toClear[r][c] = toClear[r+1][c] = toClear[r+2][c] = true;
                    }
                }
            }
            // 2x2 bomb pattern
            let bombCreated = false;
            for (let r = 0; r < gridSize - 1; r++) {
                for (let c = 0; c < gridSize - 1; c++) {
                    let candy = grid[r][c];
                    if (candy && candy !== bombCandy &&
                        grid[r][c+1] === candy &&
                        grid[r+1][c] === candy &&
                        grid[r+1][c+1] === candy) {
                        // Place bomb at top-left of 2x2, clear others
                        grid[r][c] = bombCandy;
                        toClear[r][c+1] = toClear[r+1][c] = toClear[r+1][c+1] = true;
                        bombCreated = true;
                    }
                }
            }
            // Bomb activation: if a bomb is matched, clear 3x3 area
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (toClear[r][c] && grid[r][c] === bombCandy) {
                        // Clear 3x3 area centered on bomb
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                let rr = r + dr, cc = c + dc;
                                if (rr >= 0 && rr < gridSize && cc >= 0 && cc < gridSize) {
                                    if (grid[rr][cc]) {
                                        toClear[rr][cc] = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Clear matches
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (toClear[r][c]) {
                        grid[r][c] = null;
                        matched++;
                    }
                }
            }
            return matched;
        }

        function playSound(sound, checkMuted = true) {
            if (!soundEffectsEnabled) return;
            const snd = new Audio(sound);
            if (checkMuted) {
                snd.volume = document.getElementById('bg-music')?.muted ? 0 : 1;
            }
            snd.play();
        }

        function refillGrid() {
            let newCandyCount = 0;
            let fallingMap = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
            for (let c = 0; c < gridSize; c++) {
                for (let r = gridSize - 1; r >= 0; r--) {
                    if (!grid[r][c]) {
                        // Move candies down
                        let rr = r - 1;
                        while (rr >= 0 && !grid[rr][c]) rr--;
                        if (rr >= 0) {
                            grid[r][c] = grid[rr][c];
                            grid[rr][c] = null;
                        } else {
                            grid[r][c] = randomCandy();
                            newCandyCount++;
                            fallingMap[r][c] = true;
                            setTimeout(() => {
                                playSound(soundNew);
                            }, newCandyCount * 40); // stagger sounds for effect
                        }
                    }
                }
            }
            renderGrid(undefined, fallingMap);
            setTimeout(() => {
                // Check for new matches
                let matched = findAndClearMatches();
                updateScore(matched);
                if (matched > 0) {
                    refillGrid();
                } else {
                    renderGrid();
                }
            }, 500);
        }

        function updateScore(matchCount) {
            switch (matchCount) {
                case 3: score += 30; break;
                case 4: score += 50; break;
                case 5: score += 80; break;
                case 6: score += 130; break;
                case 7: score += 210; break;
            }
            document.getElementById('score').textContent = score;
        }

        function restartGame() {
            document.getElementById('gameover-modal').style.display = 'none';
            score = 0;
            moves = 20;
            selected = null;
            gameEnded = false;
            // targetScore = 1000; // You can randomize or set dynamically if desired
            createGrid();
            // Remove any initial matches
            let initialMatched;
            do {
                initialMatched = findAndClearMatches();
                updateScore(initialMatched);
                if (initialMatched > 0) refillGrid();
            } while (initialMatched > 0);
            renderGrid();
        }

        function toggleMusic() {
            const music = document.getElementById('bg-music');
            if (music) {
                music.muted = !music.muted;
            }

            toggleMusicBtn = document.getElementById('toggle-music-btn');
            if (toggleMusicBtn) {
                toggleMusicBtn.textContent = music.muted ? '🔇 Music' : '🔊 Music';
            }

            if (!music.paused) return;
            music.play().catch(()=>{});
        }

        function toggleSoundEffects() {
            soundEffectsEnabled = !soundEffectsEnabled;
            toggleSoundEffectsBtn = document.getElementById('toggle-sound-effects-btn');
            if (toggleSoundEffectsBtn) {
                toggleSoundEffectsBtn.textContent = soundEffectsEnabled ? '🔊 Sound Effects' : '🔇 Sound Effects';
            }
        }

        // Initialize
        createGrid();
        // Remove any initial matches
        let initialMatched;
        do {
            initialMatched = findAndClearMatches();
            updateScore(initialMatched);
            if (initialMatched > 0) refillGrid();
        } while (initialMatched > 0);
        renderGrid();

        // Try to play music on load (may require user interaction)
        setTimeout(() => {
            const music = document.getElementById('bg-music');
            music.play().catch(() => {
                // If autoplay fails, show Play Music button
                const toggleMusicBtn = document.getElementById('toggle-music-btn');
                const gameButtons = document.querySelector('.game-buttons');
                let playBtn = document.getElementById('play-music-btn');
                if (!playBtn) {
                    playBtn = document.createElement('button');
                    playBtn.id = 'play-music-btn';
                    playBtn.textContent = '▶️ Play Music';
                    playBtn.style.background = '#ffd700';
                    playBtn.style.color = '#222';
                    playBtn.onclick = function() {
                        music.play().then(() => {
                            playBtn.remove();
                        }).catch(()=>{});
                    };
                    gameButtons.appendChild(playBtn);
                }
            });
        }, 500);

        setTimeout(() => {
            document.getElementById('bg-music').muted = false;
        }, 500);
    </script>
</body>
</html>
