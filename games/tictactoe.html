<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Tic-Tac-Toe</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
    <style>
        #board {
            display: grid;
            grid-template-columns: repeat(3, 104px);
            grid-gap: 1px;
            margin: 50px auto;
            width: max-content;
        }

        .cell {
            width: 100px;
            height: 100px;
            font-size: 2em;
            cursor: pointer;
            border: 2px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #message {
            font-size: 1.5em;
            margin-top: 20px;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
        }

        #ai-mode {
            margin: 20px 0;
        }

        #aiMode {
            padding: 5px 10px;
            font-size: 1em;
            margin-left: 10px;
        }
    </style>
</head>

<body>
    <a href="../index.html" title="Back to Home" class="home-link">
        <svg width="28" height="28" viewBox="0 0 24 24">
            <path d="M15 18l-6-6 6-6" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span>Home</span>
    </a>
    <h1>Tic-Tac-Toe</h1>
    <div id="game-container">
        <div id="game">
            <label for="aiMode">AI Difficulty:</label>
            <select id="aiMode" onchange="updateAIMode()">
                <option selected value="random">Random (Easy)</option>
                <option value="minimax">Minimax (Impossible)</option>
                <option value="dqn">DQN (Trained AI)</option>
                <option value="human">Human (2 Players)</option>
            </select>
            <div id="board"></div>
            <div id="message"></div>
            <button onclick="resetGame()">Restart</button>
        </div>
        <div id="rules" style="width:250px;">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Goal:</strong> Get three of your marks in a row before your opponent</li>
                <li><strong>Turn:</strong> Click an empty cell to place your mark (X for you, O for AI)</li>
                <li><strong>Win:</strong> First to get 3 marks in a line (horizontal, vertical, or diagonal)</li>
                <li><strong>Tie:</strong> If all 9 cells are filled with no winner, the game is a draw</li>
                <li><strong>AI:</strong> Choose between Random (easy) or Minimax (impossible) difficulty</li>
            </ul>

            <div class="strategy">
                <strong>Strategy Tips:</strong>
                <ul>
                    <li>Control the center - it's part of 4 different winning lines</li>
                    <li>Block your opponent when they have 2 in a row</li>
                    <li>Create forks - positions where you can win in two different ways</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const HUMAN = 'X';
        const AI = 'O';
        const TIE = 'tie';
        const EMPTY = null;
        const winning_positions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Horizontal
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Vertical
            [0, 4, 8], [2, 4, 6] // Diagonal
        ];
        let board = Array(9).fill(EMPTY);
        let aiMode = 'random'; // Default AI mode
        let currentPlayer = HUMAN; // Track whose turn it is

        const boardDiv = document.getElementById('board');
        const messageDiv = document.getElementById('message');

        // Will store [{state, action, turn}] for each move
        let gameLog = [];

        // Initialize the game board and display it
        function createBoard() {
            boardDiv.innerHTML = '';
            board.forEach((cell, idx) => {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                cellDiv.textContent = cell || '';
                // Add click event listener to each cell to handle human moves
                cellDiv.addEventListener('click', () => humanMove(idx));
                boardDiv.appendChild(cellDiv);
            });
        }

        // Handle human move
        // This function is called when a human player clicks on a cell
        // It checks if the cell is empty and if the game is still ongoing
        // If valid, it places the human's mark and checks for a winner
        // If no winner, it triggers the AI to make a move
        function humanMove(idx) {
            if (board[idx] || checkWinner(board)) return;
            // In human vs human mode, alternate between X and O
            if (aiMode === 'human') {
                gameLog.push({
                    state: translateBoardToInput(board),
                    action: idx,
                    turn: currentPlayer === HUMAN ? 1 : -1
                });
                board[idx] = currentPlayer;
                createBoard();
                const result = checkWinner(board);
                if (result !== null) {
                    endGame(result);
                } else {
                    currentPlayer = currentPlayer === HUMAN ? AI : HUMAN;
                }
            } else {
                // Only allow move if it's human's turn
                if (currentPlayer !== HUMAN) return;
                gameLog.push({
                    state: translateBoardToInput(board),
                    action: idx,
                    turn: 1
                });
                board[idx] = HUMAN;
                createBoard();
                const result = checkWinner(board);
                if (result !== null) {
                    endGame(result);
                } else {
                    setTimeout(makeAIMove, 200);
                }
            }
        }

        // Make AI move based on selected mode
        function makeAIMove() {
            if (aiMode === 'minimax') {
                aiMiniMaxMove();
            } else if (aiMode === 'dqn') {
                aiDQNMove();
            } else {
                aiRandomMove();
            }
        }

        // Update AI mode when dropdown changes
        function updateAIMode() {
            aiMode = document.getElementById('aiMode').value;
            if (aiMode === 'dqn') loadDQNModel();
            resetGame();
        }


        // --- DQN AI (TensorFlow.js) ---
        let dqnModel = null;
        let dqnModelLoaded = false;

        async function loadDQNModel() {
            if (!dqnModelLoaded) {
                try {
                    dqnModel = await tf.loadGraphModel('tfjs_model/model.json');
                    dqnModelLoaded = true;
                } catch (e) {
                    console.error('Failed to load DQN model:', e);
                }
            }
        }

        async function aiDQNMove() {
            await loadDQNModel();
            if (!dqnModel) {
                console.warn('DQN model not loaded, falling back to random move.');
                // Fallback to random if model not loaded
                aiRandomMove();
                return;
            }
            // Prepare input: X=1, O=-1, empty=0
            const inputArr = board.map(cell => cell === HUMAN ? 1 : cell === AI ? -1 : 0);
            // Mask illegal moves
            let availableMoves = board.map((cell, idx) => cell === EMPTY ? idx : null).filter(idx => idx !== null);
            if (availableMoves.length === 0) return;
            // Run inference
            console.log('DQN Input:', inputArr);
            const inputTensor = tf.tensor2d([inputArr], [1, 9]);
            let qvals = await dqnModel.predict(inputTensor).array();
            inputTensor.dispose();
            qvals = qvals[0];
            console.log('DQN Q-values:', qvals);
            // Mask illegal moves to -Infinity
            let maskedQ = qvals.map((q, idx) => availableMoves.includes(idx) ? q : -Infinity);
            // Pick the move with the highest Q value
            let bestMove = maskedQ.indexOf(Math.max(...maskedQ));
            // Log the state before the move
            gameLog.push({
                state: translateBoardToInput(board),
                action: bestMove,
                turn: -1 // AI is O, which is -1
            });
            if (board[bestMove] === EMPTY) {
                board[bestMove] = AI;
                createBoard();
                const result = checkWinner(board);
                if (result !== null) {
                    endGame(result);
                }
            } else {
                console.warn('DQN selected an illegal move:', bestMove, '. Falling back to random move.');
                aiRandomMove();
            }
        }

        function translateBoardToInput(board) {
            return board.map(cell => cell === HUMAN ? 1 : cell === AI ? -1 : 0).slice();
        }

        function logGameToConsole() {
            // Format as Python list of tuples
            let pyList = gameLog.map(
                move => `[${JSON.stringify(move.state)}, ${move.action}, ${move.turn}]`
            ).join(",\n");
            console.log("Game log for training:\n[\n" + pyList + "\n]");
            // Optionally, clear the log for the next game
            gameLog = [];
        }

        // AI makes a random move
        // This function finds all available moves (empty cells) and randomly selects one
        // It then places the AI's mark in that cell and checks for a winner
        // If a winner is found, it ends the game
        function aiRandomMove() {
            let availableMoves = board.map((cell, idx) => cell === EMPTY ? idx : null).filter(idx => idx !== null);
            if (availableMoves.length > 0) {
                const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                board[randomMove] = AI;
                createBoard();
                const result = checkWinner(board);
                if (result !== null) {
                    endGame(result);
                }
            }
        }

        // AI makes a move using the MiniMax algorithm
        // This function evaluates all possible moves using the MiniMax algorithm
        // It finds the best move for the AI and places its mark in that cell
        // After making the move, it checks for a winner
        // If a winner is found, it ends the game
        function aiMiniMaxMove() {
            let bestScore = -Infinity;
            let move;
            for (let i = 0; i < 9; i++) {
                if (!board[i]) {
                    board[i] = AI;
                    let score = minimax(board, false);
                    board[i] = EMPTY;
                    if (score > bestScore) {
                        bestScore = score;
                        move = i;
                    }
                }
            }
            board[move] = AI;
            createBoard();
            const result = checkWinner(board);
            if (result !== null) {
                endGame(result);
            }
        }

        // MiniMax algorithm to choose the best move
        function minimax(board, isMaximizing) {
            const result = checkWinner(board);
            if (result === AI) return 1;
            if (result === HUMAN) return -1;
            if (result === TIE) return 0;

            // if no winner yet, continue the search
            // if maximizing, AI is trying to maximize its score
            // if minimizing, human is trying to minimize AI's score
            // recursively call minimax for each possible move
            // and return the best score for the current player
            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (!board[i]) {
                        board[i] = AI;
                        let score = minimax(board, false);
                        board[i] = EMPTY;
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (!board[i]) {
                        board[i] = HUMAN;
                        let score = minimax(board, true);
                        board[i] = EMPTY;
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }

        // Check for a winner or tie
        // This function checks all winning positions to see if there's a winner
        // If a winner is found, it returns the winner's mark (HUMAN or AI)
        // If all cells are filled and no winner, it returns TIE
        // If no winner yet, it returns null
        function checkWinner(board) {
            for (const [a, b, c] of winning_positions) {
                if (board[a] && board[a] === board[b] && board[a] === board[c]) return board[a];
            }
            if (board.every(cell => cell)) return TIE;
            return null; // No winner yet
        }

        // End the game and display the result
        function endGame(result) {
            if (result === TIE) {
                messageDiv.textContent = "It's a tie!";
            } else {
                messageDiv.textContent = `${result} wins!`;
            }
            logGameToConsole();
        }

        // Reset the game
        function resetGame() {
            board = Array(9).fill(EMPTY);
            messageDiv.textContent = '';
            createBoard();
            gameLog = [];
            currentPlayer = HUMAN;
        }

        // Initialize the game board
        createBoard();
    </script>
</body>

</html>