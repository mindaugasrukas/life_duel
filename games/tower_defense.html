<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Tower Defense</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        #canvas {
            border: 2px solid #333;
            background: #90EE90;
            display: block;
            cursor: crosshair;
            position: relative;
        }

        .preview-mode {
            cursor: crosshair !important;
        }

        .hover-tower {
            cursor: pointer !important;
        }

        /* Canvas overlay for game stats */
        #canvas-container {
            position: relative;
            display: inline-block;
        }

        #game-stats-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }

        #wave-info-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-align: right;
        }

        #tower-upgrade-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 13px;
            z-index: 10;
            display: none;
            max-width: 300px;
            pointer-events: all;
        }

        #tower-upgrade-overlay h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 14px;
        }

        .upgrade-overlay-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .upgrade-overlay-btn:hover {
            background: #45a049;
        }

        .upgrade-overlay-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .sell-overlay-btn {
            background: #f44336 !important;
        }

        .sell-overlay-btn:hover {
            background: #da190b !important;
        }

        .tower-stats-overlay {
            margin-bottom: 10px;
            font-size: 12px;
            line-height: 1.4;
        }

        #game-mode-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 12px;
            font-family: Arial, sans-serif;
            z-index: 1000;
            max-width: 500px;
            width: 90%;
            pointer-events: all;
            display: block;
        }

        #game-mode-overlay h2 {
            color: #FFD700;
            text-align: center;
            margin: 0 0 20px 0;
        }

        .game-mode-btn {
            display: block;
            margin: 10px 0;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            text-align: left;
        }

        .game-mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #1976d2;
            transform: translateY(-2px);
        }

        .game-mode-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .game-mode-desc {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }

        .game-mode-stats {
            font-size: 11px;
            color: #FFD700;
            margin-top: 5px;
        }

        #tower-selection-overlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 13px;
            z-index: 10;
            max-width: 280px;
            pointer-events: all;
        }

        #tower-selection-overlay h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 14px;
        }

        .tower-overlay-btn {
            display: block;
            margin: 3px 0;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            text-align: left;
        }

        .tower-overlay-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #1976d2;
        }

        .tower-overlay-btn.selected {
            background: #1976d2;
            border-color: #1976d2;
        }

        .tower-overlay-btn.disabled {
            background: rgba(255, 255, 255, 0.05);
            color: #999;
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.1);
        }

        .tower-overlay-info {
            font-size: 10px;
            color: #ccc;
            margin-top: 2px;
        }

        #enemy-spawn-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 13px;
            z-index: 10;
            max-width: 280px;
            pointer-events: all;
            display: none;
        }

        #enemy-spawn-overlay h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 14px;
        }

        .enemy-spawn-btn {
            display: block;
            margin: 3px 0;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            text-align: left;
        }

        .enemy-spawn-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FF6B6B;
        }

        .enemy-spawn-info {
            font-size: 10px;
            color: #ccc;
            margin-top: 2px;
        }

        .stat-row {
            margin: 2px 0;
        }

        .stat-label {
            color: #FFD700;
        }

        #controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        #stats {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            font-weight: bold;
            flex-wrap: wrap;
        }

        .stat-item {
            padding: 8px 16px;
            background: #e8e8e8;
            border-radius: 6px;
            font-size: 0.9em;
            min-width: 60px;
        }

        .tower-btn {
            padding: 10px 15px;
            margin: 5px;
            border: 2px solid #ccc;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            min-width: 100px;
        }

        .tower-btn:hover {
            background: #f0f0f0;
            border-color: #1976d2;
        }

        .tower-btn.selected {
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        .tower-btn.disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            border-color: #ddd;
        }

        .tower-info {
            font-size: 0.8em;
            color: #666;
            margin-top: 2px;
        }

        .wave-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #1976d2;
        }

        .enemy-type {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            font-size: 0.8em;
            color: white;
        }

        .enemy-basic { background: #ff9800; }
        .enemy-fast { background: #ffeb3b; color: #333; }
        .enemy-tank { background: #d32f2f; }
        .enemy-flying { background: #03a9f4; }

        .tower-stats {
            font-size: 0.85em;
            line-height: 1.3;
        }

        .upgrade-section {
            background: #f9f9f9;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .upgrade-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        .upgrade-btn:hover {
            background: #45a049;
        }

        .upgrade-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .sell-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        .sell-btn:hover {
            background: #da190b;
        }

        .tower-selected {
            box-shadow: 0 0 0 3px #FFD700 !important;
        }

        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <a href="../index.html" title="Back to Home" class="home-link">
        <svg width="28" height="28" viewBox="0 0 24 24">
            <path d="M15 18l-6-6 6-6" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span>Home</span>
    </a>

    <div id="game-container">
        <div id="game">
            <h1>Tower Defense</h1>

            <div id="canvas-container">
                <canvas id="canvas" width="900" height="720"></canvas>

                <div id="game-stats-overlay">
                    <div class="stat-row"><span class="stat-label">Lives:</span> <span id="lives">20</span></div>
                    <div class="stat-row"><span class="stat-label">Money:</span> $<span id="money">50</span></div>
                    <div class="stat-row"><span class="stat-label">Score:</span> <span id="score">0</span></div>
                </div>

                <div id="wave-info-overlay">
                    <div class="stat-row"><span class="stat-label">Wave:</span> <span id="current-wave">1/20</span></div>
                    <div class="stat-row"><span class="stat-label">Enemies:</span> <span id="enemies-remaining-overlay">10</span></div>
                    <div class="stat-row" id="wave-status"><span class="stat-label">Status:</span> <span id="wave-status-text">Ready</span></div>
                </div>

                <div id="tower-upgrade-overlay">
                    <h4 id="selected-tower-title">Selected Tower</h4>
                    <div id="tower-stats-display" class="tower-stats-overlay"></div>
                    <button class="upgrade-overlay-btn" id="upgrade-damage-overlay-btn">
                        Upgrade Damage (+<span id="damage-increase-overlay">10</span>) - $<span id="damage-cost-overlay">20</span>
                    </button>
                    <button class="upgrade-overlay-btn" id="upgrade-range-overlay-btn">
                        Upgrade Range (+<span id="range-increase-overlay">20</span>) - $<span id="range-cost-overlay">15</span>
                    </button>
                    <button class="upgrade-overlay-btn" id="upgrade-speed-overlay-btn">
                        Upgrade Speed (+25%) - $<span id="speed-cost-overlay">25</span>
                    </button>
                    <button class="upgrade-overlay-btn sell-overlay-btn" id="sell-tower-overlay-btn">
                        Sell Tower ($<span id="sell-value-overlay">0</span>)
                    </button>
                </div>

                <div id="tower-selection-overlay">
                    <h4>Select Tower to Build:</h4>
                    <div class="tower-overlay-btn" data-tower="basic" id="basic-overlay-btn">
                        <div>Basic Tower - $10 <span style="color: #6BCF7F;">[1]</span></div>
                        <div class="tower-overlay-info">Damage: 20 | Range: 100</div>
                    </div>
                    <div class="tower-overlay-btn" data-tower="heavy" id="heavy-overlay-btn">
                        <div>Heavy Tower - $25 <span style="color: #6BCF7F;">[2]</span></div>
                        <div class="tower-overlay-info">Damage: 50 | Range: 80</div>
                    </div>
                    <div class="tower-overlay-btn" data-tower="rapid" id="rapid-overlay-btn">
                        <div>Rapid Tower - $30 <span style="color: #6BCF7F;">[3]</span></div>
                        <div class="tower-overlay-info">Damage: 15 | Range: 120</div>
                    </div>
                    <div class="tower-overlay-btn" data-tower="laser" id="laser-overlay-btn">
                        <div>Laser Tower - $50 <span style="color: #6BCF7F;">[4]</span></div>
                        <div class="tower-overlay-info">Damage: 100 | Range: 150</div>
                    </div>
                    <div class="tower-overlay-btn" data-tower="antiair" id="antiair-overlay-btn">
                        <div>Anti-Air Tower - $35 <span style="color: #6BCF7F;">[5]</span></div>
                        <div class="tower-overlay-info">Damage: 60 | Range: 130 | Air Only</div>
                    </div>
                </div>

                <div id="enemy-spawn-overlay">
                    <h4>Spawn Enemies (Sandbox):</h4>
                    <div class="enemy-spawn-btn" data-enemy="basic" id="spawn-basic-btn">
                        <div>Basic Enemy <span style="color: #6BCF7F;">[Q]</span></div>
                        <div class="enemy-spawn-info">HP: 50 | Speed: Normal | Reward: $2</div>
                    </div>
                    <div class="enemy-spawn-btn" data-enemy="fast" id="spawn-fast-btn">
                        <div>Fast Enemy <span style="color: #6BCF7F;">[W]</span></div>
                        <div class="enemy-spawn-info">HP: 30 | Speed: Fast | Reward: $3</div>
                    </div>
                    <div class="enemy-spawn-btn" data-enemy="tank" id="spawn-tank-btn">
                        <div>Tank Enemy <span style="color: #6BCF7F;">[E]</span></div>
                        <div class="enemy-spawn-info">HP: 200 | Speed: Slow | Reward: $8</div>
                    </div>
                    <div class="enemy-spawn-btn" data-enemy="flying" id="spawn-flying-btn">
                        <div>Flying Enemy <span style="color: #6BCF7F;">[R]</span></div>
                        <div class="enemy-spawn-info">HP: 40 | Speed: Fast | Reward: $4</div>
                    </div>
                </div>

                <div id="game-mode-overlay">
                    <h2>Select Game Mode</h2>

                    <div class="game-mode-btn" onclick="startGameMode('classic')">
                        <div class="game-mode-title">üèõÔ∏è Classic Mode</div>
                        <div class="game-mode-desc">Complete 20 challenging waves with limited resources. The original tower defense experience.</div>
                        <div class="game-mode-stats">20 Waves ‚Ä¢ Starting Money: $50 ‚Ä¢ Lives: 20</div>
                    </div>

                    <div class="game-mode-btn" onclick="startGameMode('sandbox')">
                        <div class="game-mode-title">üèóÔ∏è Sandbox Mode</div>
                        <div class="game-mode-desc">Unlimited money and lives. Perfect for testing strategies and experimenting with tower combinations. Manually spawn enemies!</div>
                        <div class="game-mode-stats">Infinite Waves ‚Ä¢ Money: Unlimited ‚Ä¢ Lives: Unlimited ‚Ä¢ Manual Enemy Spawn</div>
                    </div>

                    <div class="game-mode-btn" onclick="startGameMode('survival')">
                        <div class="game-mode-title">üî• Survival Mode</div>
                        <div class="game-mode-desc">Face endless waves of increasingly difficult enemies with automatic wave progression. How long can you survive?</div>
                        <div class="game-mode-stats">Endless Waves ‚Ä¢ Starting Money: $75 ‚Ä¢ Lives: 15 ‚Ä¢ Auto-progression</div>
                    </div>

                    <div class="game-mode-btn" onclick="startGameMode('speed')">
                        <div class="game-mode-title">‚ö° Speed Mode</div>
                        <div class="game-mode-desc">Fast-paced gameplay with quicker enemy spawns and shorter wave breaks. Think fast!</div>
                        <div class="game-mode-stats">25 Waves ‚Ä¢ Starting Money: $100 ‚Ä¢ Lives: 25 ‚Ä¢ 2x Speed</div>
                    </div>

                    <div class="game-mode-btn" onclick="startGameMode('economy')">
                        <div class="game-mode-title">üí∞ Economy Mode</div>
                        <div class="game-mode-desc">Start with limited money but earn more from defeating enemies. Every decision counts!</div>
                        <div class="game-mode-stats">20 Waves ‚Ä¢ Starting Money: $25 ‚Ä¢ Lives: 15 ‚Ä¢ 2x Rewards</div>
                    </div>
                </div>

                <div id="game-over-screen">
                    <h2 id="game-over-title">Game Over!</h2>
                    <p id="final-score">Final Score: 0</p>
                    <p id="waves-completed">Waves Completed: 0/20</p>
                    <button onclick="showGameModeSelection()">Play Again</button>
                    <button onclick="restartSameMode()" style="margin-left: 10px;">Same Mode</button>
                </div>
            </div>

            <div id="controls">
                <button id="start-wave-btn">Start Wave (Space)</button>
                <button id="pause-btn">Pause (Space)</button>
                <button id="speed-btn">Speed: 1.0x</button>
                <button id="restart-btn">Restart Game</button>
                <button onclick="cancelTowerSelection()" style="background: #f44336;">Cancel Selection (Esc)</button>
            </div>
        </div>

        <div id="rules">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Objective:</strong> Stop enemies from reaching the end of the path</li>
                <li><strong>Build Towers:</strong> Select a tower type and click on green areas to build</li>
                <li><strong>Start Waves:</strong> Click "Start Wave" to begin enemy attacks</li>
                <li><strong>Earn Money:</strong> Destroy enemies to earn money for more towers</li>
                <li><strong>Survive:</strong> Don't let your lives reach zero!</li>
            </ul>

            <div class="wave-info">
                <h4>Wave <span id="wave-number">1</span> Preview</h4>
                <div id="wave-enemies">
                    <span class="enemy-type enemy-basic">Basic x10</span>
                </div>
                <div style="margin-top: 8px; font-size: 0.9em;">
                    Enemies: <span id="enemies-remaining">10</span> remaining
                </div>
            </div>

            <div class="tower-stats">
                <h4>Tower Types</h4>
                <div><strong>Basic Tower ($10):</strong> Balanced damage and range (Ground only)</div>
                <div><strong>Heavy Tower ($25):</strong> High damage, slower fire rate (Ground only)</div>
                <div><strong>Rapid Tower ($30):</strong> Fast firing, lower damage (Ground only)</div>
                <div><strong>Laser Tower ($50):</strong> Pierces through multiple enemies (All targets)</div>
                <div><strong>Anti-Air Tower ($35):</strong> Specialized against flying enemies (Air only)</div>

                <h4 style="margin-top: 15px;">Upgrade Indicators</h4>
                <div style="font-size: 0.9em;">
                    <div><span style="color: #FF0000;">‚óè Red dots</span> - Damage upgrades</div>
                    <div><span style="color: #0080FF;">‚óè Blue dots</span> - Range upgrades</div>
                    <div><span style="color: #00FF00;">‚óè Green dots</span> - Speed upgrades</div>
                    <div style="margin-top: 5px; color: #666;">Click towers to upgrade them!</div>
                </div>
            </div>

            <div class="strategy">
                <h4>Strategy Tips</h4>
                <ul>
                    <li>Place towers at corners where enemies turn</li>
                    <li>Use rapid towers for groups of weak enemies</li>
                    <li>Save heavy/laser towers for tank enemies</li>
                    <li>Upgrade towers between waves for better efficiency</li>
                </ul>

                <h4>Keyboard Controls</h4>
                <ul>
                    <li><strong>Space:</strong> Start wave / Pause game</li>
                    <li><strong>Escape:</strong> Cancel tower selection</li>
                    <li><strong>S:</strong> Cycle game speed (0.5x - 3x)</li>
                    <li><strong>M:</strong> Game mode selection</li>
                    <li><strong>1-5:</strong> Select tower types (Basic/Heavy/Rapid/Laser/Anti-Air)</li>
                    <li><strong>Click tower:</strong> Select for upgrades</li>
                </ul>
            </div>

            <div class="upgrade-section" id="selected-tower-info" style="display: none;">
                <h4>Selected Tower</h4>
                <div id="tower-details"></div>
                <div id="tower-upgrade-buttons">
                    <button class="upgrade-btn" id="upgrade-damage-btn">
                        Upgrade Damage (+<span id="damage-increase">10</span>) - $<span id="damage-cost">20</span>
                    </button>
                    <button class="upgrade-btn" id="upgrade-range-btn">
                        Upgrade Range (+<span id="range-increase">20</span>) - $<span id="range-cost">15</span>
                    </button>
                    <button class="upgrade-btn" id="upgrade-speed-btn">
                        Upgrade Speed (+25%) - $<span id="speed-cost">25</span>
                    </button>
                    <button class="sell-btn" id="sell-tower-btn">
                        Sell Tower ($<span id="sell-value">0</span>)
                    </button>
                </div>
                <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                    Click elsewhere to deselect tower
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state variables
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let gameState = 'menu'; // 'menu', 'building', 'playing', 'paused', 'game-over', 'wave-break'
        let currentGameMode = 'classic';
        let selectedTowerType = 'basic';
        let selectedTower = null;
        let currentWave = 1;
        let money = 50;
        let lives = 20;
        let score = 0;
        let waveInProgress = false;
        let waveBreakTimer = 0;
        let waveBreakStartTime = 0;
        let spawnInterval = null;
        let mouseX = 0;
        let mouseY = 0;
        let showPreview = false;
        let gameSpeed = 1; // Game speed multiplier
        let gameSpeedOptions = [0.5, 1, 2, 3]; // Available speed options
        let gameSpeedIndex = 1; // Current index in gameSpeedOptions (starts at 1x)

        // Game mode configurations
        const gameModes = {
            classic: {
                name: 'Classic',
                startingMoney: 50,
                startingLives: 20,
                maxWaves: 20,
                rewardMultiplier: 1,
                enemySpeedMultiplier: 1,
                waveBreakDuration: 10000, // 10 seconds
                infiniteMoney: false,
                infiniteLives: false
            },
            sandbox: {
                name: 'Sandbox',
                startingMoney: 999999,
                startingLives: 999,
                maxWaves: Infinity,
                rewardMultiplier: 1,
                enemySpeedMultiplier: 1,
                waveBreakDuration: 5000,
                infiniteMoney: true,
                infiniteLives: true
            },
            survival: {
                name: 'Survival',
                startingMoney: 75,
                startingLives: 15,
                maxWaves: Infinity,
                rewardMultiplier: 1.2,
                enemySpeedMultiplier: 1,
                waveBreakDuration: 2000, // 2 seconds for intense gameplay
                infiniteMoney: false,
                infiniteLives: false
            },
            speed: {
                name: 'Speed',
                startingMoney: 100,
                startingLives: 25,
                maxWaves: 25,
                rewardMultiplier: 1.5,
                enemySpeedMultiplier: 2,
                waveBreakDuration: 3000, // 3 seconds
                infiniteMoney: false,
                infiniteLives: false
            },
            economy: {
                name: 'Economy',
                startingMoney: 25,
                startingLives: 15,
                maxWaves: 20,
                rewardMultiplier: 2,
                enemySpeedMultiplier: 1,
                waveBreakDuration: 10000,
                infiniteMoney: false,
                infiniteLives: false
            }
        };

        // Game objects
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let explosions = [];

        // Tower definitions
        const towerTypes = {
            basic: { cost: 10, damage: 20, range: 100, fireRate: 60, color: '#2196F3', name: 'Basic', canHitGround: true, canHitAir: false },
            heavy: { cost: 25, damage: 50, range: 80, fireRate: 120, color: '#F44336', name: 'Heavy', canHitGround: true, canHitAir: false },
            rapid: { cost: 30, damage: 15, range: 120, fireRate: 20, color: '#4CAF50', name: 'Rapid', canHitGround: true, canHitAir: false },
            laser: { cost: 50, damage: 100, range: 150, fireRate: 240, color: '#9C27B0', name: 'Laser', piercing: true, canHitGround: true, canHitAir: true },
            antiair: { cost: 35, damage: 60, range: 130, fireRate: 40, color: '#FF5722', name: 'Anti-Air', canHitGround: false, canHitAir: true }
        };

        // Upgrade costs and bonuses
        const upgradeConfig = {
            damage: { baseCost: 20, costMultiplier: 1.5, bonus: 10 },
            range: { baseCost: 15, costMultiplier: 1.3, bonus: 20 },
            speed: { baseCost: 25, costMultiplier: 1.4, bonus: 0.75 } // multiplier for fire rate (faster = lower number)
        };

        // Enemy types for waves
        const enemyTypes = {
            basic: { hp: 50, speed: 2, reward: 2, color: '#FF9800', name: 'Basic', isFlying: false },
            fast: { hp: 30, speed: 4, reward: 3, color: '#FFEB3B', name: 'Fast', isFlying: false },
            tank: { hp: 200, speed: 1, reward: 8, color: '#D32F2F', name: 'Tank', isFlying: false },
            flying: { hp: 40, speed: 3, reward: 4, color: '#03A9F4', name: 'Flying', isFlying: true }
        };

        // Path definition (simplified - we'll make this more complex later)
        const path = [
            {x: 0, y: 360}, {x: 150, y: 360}, {x: 150, y: 180},
            {x: 300, y: 180}, {x: 300, y: 540}, {x: 600, y: 540},
            {x: 600, y: 120}, {x: 750, y: 120}, {x: 750, y: 360}, {x: 900, y: 360}
        ];

        // Initialize game
        function initGame() {
            showGameModeSelection();
            setupEventListeners();
        }

        function showGameModeSelection() {
            gameState = 'menu';
            document.getElementById('game-mode-overlay').style.display = 'block';
            document.getElementById('game-over-screen').style.display = 'none';

            // Hide all game overlays
            document.getElementById('tower-upgrade-overlay').style.display = 'none';
            document.getElementById('tower-selection-overlay').style.display = 'none';
            document.getElementById('enemy-spawn-overlay').style.display = 'none';
        }

        function startGameMode(mode) {
            currentGameMode = mode;
            const config = gameModes[mode];

            document.getElementById('game-mode-overlay').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';

            // Initialize game with mode-specific settings
            gameState = 'building';
            currentWave = 1;
            money = config.startingMoney;
            lives = config.startingLives;
            score = 0;
            waveInProgress = false;
            waveBreakTimer = 0;
            waveBreakStartTime = 0;
            showPreview = false;

            // Clear any existing spawn interval
            if (spawnInterval) {
                clearInterval(spawnInterval);
                spawnInterval = null;
            }

            // Clear game objects
            towers = [];
            enemies = [];
            projectiles = [];
            explosions = [];

            // Deselect everything
            selectedTower = null;
            document.getElementById('tower-upgrade-overlay').style.display = 'none';

            // Show game overlays
            document.getElementById('tower-selection-overlay').style.display = 'block';

            // Show enemy spawn overlay only in sandbox mode
            if (currentGameMode === 'sandbox') {
                document.getElementById('enemy-spawn-overlay').style.display = 'block';
            } else {
                document.getElementById('enemy-spawn-overlay').style.display = 'none';
            }

            // Reset UI
            document.getElementById('start-wave-btn').disabled = false;
            document.getElementById('pause-btn').textContent = 'Pause';
            canvas.classList.remove('preview-mode', 'hover-tower');

            // Select first tower type to enable preview
            selectTowerType('basic');

            updateUI();
            updateWavePreview();
            drawGame();
        }

        function restartSameMode() {
            startGameMode(currentGameMode);
        }

        function setupEventListeners() {
            // Canvas click for tower placement
            canvas.addEventListener('click', handleCanvasClick);

            // Canvas mouse movement for preview
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseenter', handleCanvasMouseEnter);
            canvas.addEventListener('mouseleave', handleCanvasMouseLeave);

            // Keyboard controls
            document.addEventListener('keydown', handleKeyPress);

            // Tower selection buttons (both old and new overlay versions)
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectTowerType(btn.dataset.tower);
                });
            });

            // New overlay tower selection buttons
            document.querySelectorAll('.tower-overlay-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectTowerType(btn.dataset.tower);
                });
            });

            // Control buttons
            document.getElementById('start-wave-btn').addEventListener('click', startWave);
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('speed-btn').addEventListener('click', cycleGameSpeed);
            document.getElementById('restart-btn').addEventListener('click', restartGame);

            // Upgrade buttons (both old and new overlay versions)
            document.getElementById('upgrade-damage-btn')?.addEventListener('click', () => upgradeTower('damage'));
            document.getElementById('upgrade-range-btn')?.addEventListener('click', () => upgradeTower('range'));
            document.getElementById('upgrade-speed-btn')?.addEventListener('click', () => upgradeTower('speed'));
            document.getElementById('sell-tower-btn')?.addEventListener('click', sellTower);

            // New overlay upgrade buttons
            document.getElementById('upgrade-damage-overlay-btn').addEventListener('click', () => upgradeTower('damage'));
            document.getElementById('upgrade-range-overlay-btn').addEventListener('click', () => upgradeTower('range'));
            document.getElementById('upgrade-speed-overlay-btn').addEventListener('click', () => upgradeTower('speed'));
            document.getElementById('sell-tower-overlay-btn').addEventListener('click', sellTower);

            // Enemy spawn buttons (for sandbox mode)
            document.querySelectorAll('.enemy-spawn-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (currentGameMode === 'sandbox') {
                        spawnEnemyManually(btn.dataset.enemy);
                    }
                });
            });
        }

        function selectTowerType(type) {
            selectedTowerType = type;

            // Deselect any selected tower
            if (selectedTower) {
                selectedTower = null;
                document.getElementById('tower-upgrade-overlay').style.display = 'none';
                const oldPanel = document.getElementById('selected-tower-info');
                if (oldPanel) oldPanel.style.display = 'none';
            }

            showPreview = true;

            // Update button states for both old and new buttons
            document.querySelectorAll('.tower-btn, .tower-overlay-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelectorAll(`[data-tower="${type}"]`).forEach(btn => {
                btn.classList.add('selected');
            });

            // Update canvas cursor
            canvas.classList.add('preview-mode');

            drawGame(); // Immediate redraw to show preview
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if clicking on existing tower (increased detection radius)
            const clickedTower = towers.find(tower =>
                Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2) < 30
            );

            if (clickedTower) {
                // Always select tower when clicked, disable preview mode
                selectTower(clickedTower);
                return;
            }

            // If tower is selected and clicking elsewhere, deselect and go back to preview
            if (selectedTower) {
                deselectTower();
                return;
            }

            // Try to place new tower if in preview mode
            if (showPreview && canPlaceTower(x, y) && canAffordTower(selectedTowerType)) {
                placeTower(x, y, selectedTowerType);
                return;
            }
        }

        function handleCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;

            // Check if hovering over a tower
            const hoverTower = towers.find(tower =>
                Math.sqrt((tower.x - mouseX) ** 2 + (tower.y - mouseY) ** 2) < 30
            );

            // Update cursor based on what's under mouse
            if (hoverTower) {
                canvas.classList.remove('preview-mode');
                canvas.classList.add('hover-tower');
                // Disable preview when hovering over towers
                if (showPreview && !selectedTower) {
                    drawGame(); // Redraw to remove preview
                }
            } else if (showPreview && !selectedTower) {
                canvas.classList.remove('hover-tower');
                canvas.classList.add('preview-mode');
                drawGame(); // Redraw to show preview
            } else {
                canvas.classList.remove('preview-mode', 'hover-tower');
            }
        }

        function handleCanvasMouseEnter() {
            if (!selectedTower && gameState !== 'menu' && gameState !== 'game-over') {
                showPreview = true;
            }
        }

        function handleCanvasMouseLeave() {
            if (!selectedTower) {
                showPreview = false;
                canvas.classList.remove('preview-mode', 'hover-tower');
                drawGame(); // Redraw to remove preview
            }
        }

        function handleKeyPress(event) {
            switch(event.code) {
                case 'Space':
                    event.preventDefault();
                    if ((gameState === 'building' || gameState === 'wave-break') && !waveInProgress) {
                        startWave();
                    } else if (gameState === 'playing' || gameState === 'paused') {
                        togglePause();
                    }
                    break;
                case 'Escape':
                    if (selectedTower) {
                        deselectTower();
                    } else {
                        cancelTowerSelection();
                    }
                    break;
                case 'Digit1':
                    selectTowerType('basic');
                    break;
                case 'Digit2':
                    selectTowerType('heavy');
                    break;
                case 'Digit3':
                    selectTowerType('rapid');
                    break;
                case 'Digit4':
                    selectTowerType('laser');
                    break;
                case 'Digit5':
                    selectTowerType('antiair');
                    break;
                case 'KeyM':
                    if (gameState !== 'menu') {
                        showGameModeSelection();
                    }
                    break;
                case 'KeyS':
                    if (gameState !== 'menu') {
                        cycleGameSpeed();
                    }
                    break;
                case 'KeyQ':
                    if (currentGameMode === 'sandbox') {
                        spawnEnemyManually('basic');
                    }
                    break;
                case 'KeyW':
                    if (currentGameMode === 'sandbox') {
                        spawnEnemyManually('fast');
                    }
                    break;
                case 'KeyE':
                    if (currentGameMode === 'sandbox') {
                        spawnEnemyManually('tank');
                    }
                    break;
                case 'KeyR':
                    if (currentGameMode === 'sandbox') {
                        spawnEnemyManually('flying');
                    }
                    break;
            }
        }

        function canPlaceTower(x, y) {
            // Check if position is on path or too close to path
            for (let i = 0; i < path.length - 1; i++) {
                const dist = distanceToLineSegment(x, y, path[i], path[i + 1]);
                if (dist < 40) return false; // Too close to path
            }

            // Check if too close to other towers
            for (let tower of towers) {
                if (Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2) < 50) {
                    return false;
                }
            }

            return true;
        }

        // Utility function for path collision detection
        function distanceToLineSegment(x, y, p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length === 0) return Math.sqrt((x - p1.x) ** 2 + (y - p1.y) ** 2);

            const t = Math.max(0, Math.min(1, ((x - p1.x) * dx + (y - p1.y) * dy) / (length * length)));
            const projection = { x: p1.x + t * dx, y: p1.y + t * dy };

            return Math.sqrt((x - projection.x) ** 2 + (y - projection.y) ** 2);
        }

        function canAffordTower(type) {
            const config = gameModes[currentGameMode];
            return config.infiniteMoney || money >= towerTypes[type].cost;
        }

        function placeTower(x, y, type) {
            const towerDef = towerTypes[type];
            const config = gameModes[currentGameMode];

            if (!config.infiniteMoney && money < towerDef.cost) {
                return;
            }

            // Deduct money (unless infinite money mode)
            if (!config.infiniteMoney) {
                money -= towerDef.cost;
            }

            score += 10;            towers.push({
                x, y, type, level: 1,
                lastFired: 0,
                target: null,
                damageUpgrades: 0,
                rangeUpgrades: 0,
                speedUpgrades: 0,
                totalInvested: towerDef.cost,
                ...towerDef
            });

            // Keep preview mode active for continuous building
            showPreview = true;

            updateUI();
            drawGame();
        }

        function selectTower(tower) {
            selectedTower = tower;
            showPreview = false;
            canvas.classList.remove('preview-mode', 'hover-tower');

            // Show tower upgrade overlay
            const overlayPanel = document.getElementById('tower-upgrade-overlay');
            const titleDiv = document.getElementById('selected-tower-title');
            const statsDiv = document.getElementById('tower-stats-display');

            // Calculate current stats
            const currentDamage = tower.damage + (tower.damageUpgrades * upgradeConfig.damage.bonus);
            const currentRange = tower.range + (tower.rangeUpgrades * upgradeConfig.range.bonus);
            const currentFireRate = tower.fireRate * Math.pow(upgradeConfig.speed.bonus, tower.speedUpgrades);

            titleDiv.textContent = `${tower.name} Tower`;

            statsDiv.innerHTML = `
                <div>Damage: ${Math.round(currentDamage)} ${tower.damageUpgrades > 0 ? `<span style="color: #FF6B6B;">(+${tower.damageUpgrades})</span>` : ''}</div>
                <div>Range: ${Math.round(currentRange)} ${tower.rangeUpgrades > 0 ? `<span style="color: #6BCFFF;">(+${tower.rangeUpgrades})</span>` : ''}</div>
                <div>Fire Rate: ${(60/currentFireRate).toFixed(1)}/sec ${tower.speedUpgrades > 0 ? `<span style="color: #6BCF7F;">(+${tower.speedUpgrades})</span>` : ''}</div>
                <div>Total Invested: $${tower.totalInvested}</div>
            `;

            // Update upgrade button costs
            updateUpgradeButtonsOverlay(tower);

            overlayPanel.style.display = 'block';

            // Hide enemy spawn overlay to make room for tower upgrade overlay
            document.getElementById('enemy-spawn-overlay').style.display = 'none';

            // Hide old sidebar panel if it exists
            const oldPanel = document.getElementById('selected-tower-info');
            if (oldPanel) oldPanel.style.display = 'none';

            drawGame(); // Redraw to show selection
        }

        function deselectTower() {
            selectedTower = null;

            // Hide upgrade overlay
            document.getElementById('tower-upgrade-overlay').style.display = 'none';

            // Show enemy spawn overlay again if in sandbox mode
            if (currentGameMode === 'sandbox') {
                document.getElementById('enemy-spawn-overlay').style.display = 'block';
            }

            // Hide old sidebar panel if it exists
            const oldPanel = document.getElementById('selected-tower-info');
            if (oldPanel) oldPanel.style.display = 'none';

            // Return to preview mode for building towers
            showPreview = true;
            canvas.classList.add('preview-mode');

            drawGame(); // Redraw to remove tower selection highlight
        }

        function cancelTowerSelection() {
            // Clear all selections and disable preview
            selectedTower = null;
            showPreview = false;

            // Hide upgrade overlay
            document.getElementById('tower-upgrade-overlay').style.display = 'none';

            // Show enemy spawn overlay again if in sandbox mode
            if (currentGameMode === 'sandbox') {
                document.getElementById('enemy-spawn-overlay').style.display = 'block';
            }

            // Hide old sidebar panel if it exists
            const oldPanel = document.getElementById('selected-tower-info');
            if (oldPanel) oldPanel.style.display = 'none';

            // Clear tower type selection for both old and new buttons
            document.querySelectorAll('.tower-btn, .tower-overlay-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            canvas.classList.remove('preview-mode', 'hover-tower');
            canvas.style.cursor = 'default';

            drawGame();
        }

        function updateUpgradeButtonsOverlay(tower) {
            const config = gameModes[currentGameMode];

            // Calculate upgrade costs
            const damageCost = Math.round(upgradeConfig.damage.baseCost * Math.pow(upgradeConfig.damage.costMultiplier, tower.damageUpgrades));
            const rangeCost = Math.round(upgradeConfig.range.baseCost * Math.pow(upgradeConfig.range.costMultiplier, tower.rangeUpgrades));
            const speedCost = Math.round(upgradeConfig.speed.baseCost * Math.pow(upgradeConfig.speed.costMultiplier, tower.speedUpgrades));
            const sellValue = Math.round(tower.totalInvested * 0.7);

            // Update overlay button text and state
            document.getElementById('damage-cost-overlay').textContent = config.infiniteMoney ? '‚àû' : damageCost;
            document.getElementById('range-cost-overlay').textContent = config.infiniteMoney ? '‚àû' : rangeCost;
            document.getElementById('speed-cost-overlay').textContent = config.infiniteMoney ? '‚àû' : speedCost;
            document.getElementById('sell-value-overlay').textContent = config.infiniteMoney ? '‚àû' : sellValue;

            // Enable/disable overlay buttons based on money
            document.getElementById('upgrade-damage-overlay-btn').disabled = !config.infiniteMoney && money < damageCost;
            document.getElementById('upgrade-range-overlay-btn').disabled = !config.infiniteMoney && money < rangeCost;
            document.getElementById('upgrade-speed-overlay-btn').disabled = !config.infiniteMoney && money < speedCost;
        }

        function startWave() {
            if (waveInProgress) return;

            // Clear any existing spawn interval
            if (spawnInterval) {
                clearInterval(spawnInterval);
                spawnInterval = null;
            }

            waveInProgress = true;
            gameState = 'playing';

            // Generate wave enemies
            spawnWaveEnemies();

            document.getElementById('start-wave-btn').disabled = true;
        }

        function spawnWaveEnemies() {
            const waveConfig = getWaveConfig(currentWave);
            let spawnCount = 0;
            let lastSpawnTime = Date.now();

            spawnInterval = setInterval(() => {
                const currentTime = Date.now();
                const timeSinceLastSpawn = currentTime - lastSpawnTime;
                const baseSpawnDelay = 1000; // Base 1 second between spawns
                const adjustedSpawnDelay = baseSpawnDelay / gameSpeed;

                if (spawnCount >= waveConfig.totalEnemies) {
                    clearInterval(spawnInterval);
                    spawnInterval = null;
                    return;
                }

                if (timeSinceLastSpawn >= adjustedSpawnDelay) {
                    const enemyType = waveConfig.enemies[spawnCount % waveConfig.enemies.length];
                    spawnEnemy(enemyType);
                    spawnCount++;
                    lastSpawnTime = currentTime;
                }
            }, 50); // Check every 50ms for smooth speed changes
        }

        function getWaveConfig(wave) {
            const config = gameModes[currentGameMode];
            let totalEnemies, enemies;

            // Special progression for survival mode - more variety earlier
            if (currentGameMode === 'survival') {
                if (wave <= 2) {
                    totalEnemies = 8 + wave * 2;
                    enemies = ['basic'];
                } else if (wave <= 5) {
                    totalEnemies = 10 + wave * 2;
                    enemies = ['basic', 'fast'];
                } else if (wave <= 8) {
                    totalEnemies = 12 + wave * 2;
                    enemies = ['basic', 'fast', 'tank'];
                } else if (wave <= 12) {
                    totalEnemies = 15 + wave * 2;
                    enemies = ['basic', 'fast', 'tank', 'flying'];
                } else {
                    // High waves - all enemy types with scaling
                    totalEnemies = 20 + Math.floor(wave / 3) * 5;
                    enemies = ['basic', 'fast', 'tank', 'flying'];

                    // Add more challenge for very high waves
                    if (wave > 20) {
                        totalEnemies += Math.floor((wave - 20) / 5) * 8;
                    }
                }
            } else {
                // Base wave progression for other modes
                if (wave <= 5) {
                    totalEnemies = 8 + wave * 2;
                    enemies = ['basic'];
                } else if (wave <= 10) {
                    totalEnemies = 10 + wave * 2;
                    enemies = ['basic', 'fast'];
                } else if (wave <= 15) {
                    totalEnemies = 12 + wave * 2;
                    enemies = ['basic', 'fast', 'tank'];
                } else if (wave <= 20) {
                    totalEnemies = 15 + wave * 2;
                    enemies = ['basic', 'fast', 'tank', 'flying'];
                } else {
                    // Survival/endless mode scaling
                    totalEnemies = 20 + Math.floor(wave / 5) * 5;
                    enemies = ['basic', 'fast', 'tank', 'flying'];

                    // Add more challenge for very high waves
                    if (wave > 30) {
                        totalEnemies += Math.floor((wave - 30) / 10) * 10;
                    }
                }
            }

            // Adjust for game mode
            if (currentGameMode === 'speed') {
                totalEnemies = Math.round(totalEnemies * 1.5);
            } else if (currentGameMode === 'economy') {
                totalEnemies = Math.round(totalEnemies * 0.8);
            }

            return { totalEnemies, enemies };
        }

        function spawnEnemy(type) {
            const enemyDef = enemyTypes[type];
            const config = gameModes[currentGameMode];

            enemies.push({
                ...enemyDef,
                type,
                x: path[0].x,
                y: path[0].y,
                pathIndex: 0,
                pathProgress: 0,
                maxHp: enemyDef.hp,
                speed: enemyDef.speed * config.enemySpeedMultiplier,
                reward: Math.round(enemyDef.reward * config.rewardMultiplier)
            });
        }

        function spawnEnemyManually(type) {
            // Only allow manual spawning in sandbox mode
            if (currentGameMode !== 'sandbox') return;

            // Spawn the enemy immediately
            spawnEnemy(type);
        }

        function updateGame() {
            // Update game objects if game is not over
            if (gameState !== 'game-over' && gameState !== 'menu') {
                updateUI();
                checkGameState();
                // Always update enemies and projectiles so they keep moving
                updateEnemies();
                updateProjectiles();
                updateExplosions();
                updateTowers();
            }

            drawGame();
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Move enemy along path
                moveEnemyAlongPath(enemy);

                // Check if enemy reached end
                if (enemy.pathIndex >= path.length - 1) {
                    const config = gameModes[currentGameMode];

                    // Lose life (unless infinite lives mode)
                    if (!config.infiniteLives) {
                        lives--;
                    }

                    enemies.splice(i, 1);
                }

                // Remove dead enemies
                if (enemy.hp <= 0) {
                    const config = gameModes[currentGameMode];

                    // Add money (unless infinite money mode)
                    if (!config.infiniteMoney) {
                        money += enemy.reward;
                    }

                    score += enemy.reward * 10;
                    enemies.splice(i, 1);

                    // Add explosion effect
                    addExplosion(enemy.x, enemy.y);
                }
            }
        }

        function moveEnemyAlongPath(enemy) {
            if (enemy.isFlying) {
                // Flying enemies take direct path from start to end
                const startX = path[0].x;
                const startY = path[0].y;
                const endX = path[path.length - 1].x;
                const endY = path[path.length - 1].y;

                const totalDistance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
                enemy.pathProgress += (enemy.speed * gameSpeed) / totalDistance;

                if (enemy.pathProgress >= 1) {
                    // Reached the end
                    enemy.pathIndex = path.length;
                    enemy.x = endX;
                    enemy.y = endY;
                } else {
                    enemy.x = startX + (endX - startX) * enemy.pathProgress;
                    enemy.y = startY + (endY - startY) * enemy.pathProgress;
                }
            } else {
                // Ground enemies follow the path
                if (enemy.pathIndex >= path.length - 1) return;

                const current = path[enemy.pathIndex];
                const next = path[enemy.pathIndex + 1];

                const dx = next.x - current.x;
                const dy = next.y - current.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                enemy.pathProgress += (enemy.speed * gameSpeed) / distance;

                if (enemy.pathProgress >= 1) {
                    enemy.pathIndex++;
                    enemy.pathProgress = 0;
                    if (enemy.pathIndex < path.length) {
                        enemy.x = path[enemy.pathIndex].x;
                        enemy.y = path[enemy.pathIndex].y;
                    }
                } else {
                    enemy.x = current.x + (dx * enemy.pathProgress);
                    enemy.y = current.y + (dy * enemy.pathProgress);
                }
            }
        }

        function updateTowers() {
            for (let tower of towers) {
                tower.lastFired += gameSpeed;

                // Check if current target is still valid (alive and in range)
                if (tower.target && (tower.target.hp <= 0 || !enemies.includes(tower.target) || !isEnemyInRange(tower, tower.target))) {
                    tower.target = null;
                }

                // Find new target if we don't have one
                if (!tower.target) {
                    tower.target = findNearestEnemy(tower);
                }

                // Fire at target - use upgraded fire rate
                const currentFireRate = tower.fireRate * Math.pow(upgradeConfig.speed.bonus, tower.speedUpgrades);
                if (tower.target && tower.lastFired >= currentFireRate) {
                    fireProjectile(tower, tower.target);
                    tower.lastFired = 0;
                }
            }
        }

        function findNearestEnemy(tower) {
            let bestTarget = null;
            const currentRange = tower.range + (tower.rangeUpgrades * upgradeConfig.range.bonus);
            let bestScore = -1;

            for (let enemy of enemies) {
                // Check if tower can target this enemy type
                if (enemy.isFlying && !tower.canHitAir) continue;
                if (!enemy.isFlying && !tower.canHitGround) continue;

                const distance = Math.sqrt((tower.x - enemy.x) ** 2 + (tower.y - enemy.y) ** 2);

                // Only consider enemies within range
                if (distance <= currentRange) {
                    // For flying enemies, use direct progress from start to end
                    let pathProgress;
                    if (enemy.isFlying) {
                        pathProgress = enemy.pathProgress;
                    } else {
                        pathProgress = enemy.pathIndex + enemy.pathProgress;
                    }

                    // Score combines path progress (higher is better) and inverse distance (closer is better)
                    const score = pathProgress * 10 + (currentRange - distance) / currentRange;

                    if (score > bestScore) {
                        bestTarget = enemy;
                        bestScore = score;
                    }
                }
            }

            return bestTarget;
        }

        function isEnemyInRange(tower, enemy) {
            if (!enemy || enemy.hp <= 0) return false;

            const distance = Math.sqrt((tower.x - enemy.x) ** 2 + (tower.y - enemy.y) ** 2);
            const currentRange = tower.range + (tower.rangeUpgrades * upgradeConfig.range.bonus);
            return distance <= currentRange;
        }

        function fireProjectile(tower, target) {
            const currentDamage = tower.damage + (tower.damageUpgrades * upgradeConfig.damage.bonus);

            projectiles.push({
                x: tower.x,
                y: tower.y,
                targetX: target.x,
                targetY: target.y,
                damage: currentDamage,
                speed: 8,
                piercing: tower.piercing || false
            });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                // Store old position for collision detection
                const oldX = proj.x;
                const oldY = proj.y;

                // Move projectile
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const effectiveSpeed = proj.speed * gameSpeed;

                if (distance < effectiveSpeed) {
                    // Projectile reached target area, remove it
                    projectiles.splice(i, 1);
                    continue;
                } else {
                    proj.x += (dx / distance) * effectiveSpeed;
                    proj.y += (dy / distance) * effectiveSpeed;
                }

                // Check for collisions along the projectile's path
                const hit = checkProjectileCollision(oldX, oldY, proj.x, proj.y, proj.damage, proj.piercing);
                if (hit) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function checkProjectileCollision(x1, y1, x2, y2, damage, piercing) {
            const hitRadius = 15; // Collision radius for projectiles
            let hitAnyEnemy = false;

            for (let enemy of enemies) {
                // Calculate distance from enemy to the projectile's line segment
                const distanceToLine = distanceFromPointToLineSegment(enemy.x, enemy.y, x1, y1, x2, y2);

                if (distanceToLine <= hitRadius) {
                    enemy.hp -= damage;
                    hitAnyEnemy = true;

                    // Add explosion effect at collision point
                    addExplosion(enemy.x, enemy.y);

                    if (!piercing) {
                        break; // Only hit one enemy unless piercing
                    }
                }
            }

            return hitAnyEnemy;
        }

        function distanceFromPointToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;

            if (lengthSquared === 0) {
                // Line segment is actually a point
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }

            // Calculate the projection of the point onto the line
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSquared));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;

            // Return distance from point to projection
            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }

        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.life += gameSpeed;

                if (explosion.life > 30) {
                    explosions.splice(i, 1);
                }
            }
        }

        function addExplosion(x, y) {
            explosions.push({ x, y, life: 0 });
        }

        function checkGameState() {
            const config = gameModes[currentGameMode];

            // Check game over (unless infinite lives)
            if (lives <= 0 && !config.infiniteLives) {
                gameState = 'game-over';
                showGameEndScreen(victory = false);
                return;
            }

            // Check wave complete
            if (enemies.length === 0 && waveInProgress) {
                waveInProgress = false;
                currentWave++;

                // Check if game is won (finite waves mode)
                if (currentWave > config.maxWaves && config.maxWaves !== Infinity) {
                    gameState = 'game-over';
                    showGameEndScreen(victory = true);
                    return;
                }

                // Start wave break
                gameState = 'wave-break';
                waveBreakStartTime = Date.now();
                updateWavePreview();

                // Auto-transition after break duration
                setTimeout(() => {
                    if (gameState === 'wave-break') {
                        if (currentGameMode === 'survival') {
                            // Auto-start next wave in survival mode
                            startWave();
                        } else {
                            // Return to building state for manual start
                            gameState = 'building';
                        }
                    }
                }, config.waveBreakDuration);
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw path
            drawPath();

            // Draw towers
            for (let tower of towers) {
                drawTower(tower);
            }

            // Draw enemies
            for (let enemy of enemies) {
                drawEnemy(enemy);
            }

            // Draw projectiles
            for (let proj of projectiles) {
                drawProjectile(proj);
            }

            // Draw explosions
            for (let explosion of explosions) {
                drawExplosion(explosion);
            }

            // Draw tower placement preview
            if (showPreview && !selectedTower) {
                drawTowerPreview();
            }
        }

        function drawPath() {
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
        }

        function drawTower(tower) {
            // Draw range if this tower is selected
            if (selectedTower === tower) {
                drawTowerRange(tower);
            }

            // Draw selection highlight first (larger)
            if (selectedTower === tower) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.strokeRect(tower.x - 23, tower.y - 23, 46, 46);
            }

            // Draw tower base
            ctx.fillStyle = tower.color;
            ctx.fillRect(tower.x - 20, tower.y - 20, 40, 40);

            // Draw tower border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(tower.x - 20, tower.y - 20, 40, 40);

            // Draw upgrade indicators - more visible
            const damageUpgrades = tower.damageUpgrades || 0;
            const rangeUpgrades = tower.rangeUpgrades || 0;
            const speedUpgrades = tower.speedUpgrades || 0;

            // Draw damage upgrades (red dots on top)
            if (damageUpgrades > 0) {
                ctx.fillStyle = '#FF0000';
                for (let i = 0; i < Math.min(damageUpgrades, 3); i++) {
                    ctx.beginPath();
                    ctx.arc(tower.x - 12 + (i * 6), tower.y - 28, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw range upgrades (blue dots on left)
            if (rangeUpgrades > 0) {
                ctx.fillStyle = '#0080FF';
                for (let i = 0; i < Math.min(rangeUpgrades, 3); i++) {
                    ctx.beginPath();
                    ctx.arc(tower.x - 28, tower.y - 12 + (i * 6), 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw speed upgrades (green dots on right)
            if (speedUpgrades > 0) {
                ctx.fillStyle = '#00FF00';
                for (let i = 0; i < Math.min(speedUpgrades, 3); i++) {
                    ctx.beginPath();
                    ctx.arc(tower.x + 28, tower.y - 12 + (i * 6), 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw tower type indicator
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            const typeChar = tower.type.charAt(0).toUpperCase();
            ctx.strokeText(typeChar, tower.x, tower.y + 4);
            ctx.fillText(typeChar, tower.x, tower.y + 4);
        }

        function drawEnemy(enemy) {
            // Draw enemy
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 15, 0, Math.PI * 2);
            ctx.fill();

            // Draw visual indicator for flying enemies
            if (enemy.isFlying) {
                // Draw wings or flight indicator
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚úà', enemy.x, enemy.y + 3);

                // Draw shadow to show it's flying
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(enemy.x, enemy.y + 20, 12, 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw health bar
            drawHealthBar(enemy);
        }

        function drawHealthBar(enemy) {
            const barWidth = 24;
            const barHeight = 4;
            const healthPercent = enemy.hp / enemy.maxHp;

            // Background
            ctx.fillStyle = 'red';
            ctx.fillRect(enemy.x - barWidth/2, enemy.y - 25, barWidth, barHeight);

            // Health
            ctx.fillStyle = 'green';
            ctx.fillRect(enemy.x - barWidth/2, enemy.y - 25, barWidth * healthPercent, barHeight);
        }

        function drawProjectile(proj) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawExplosion(explosion) {
            const alpha = 1 - (explosion.life / 30);
            ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, explosion.life * 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTowerRange(tower) {
            const currentRange = tower.range + (tower.rangeUpgrades * upgradeConfig.range.bonus);

            // Draw range circle
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            ctx.arc(tower.x, tower.y, currentRange, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawTowerPreview() {
            if (mouseX <= 0 || mouseX >= canvas.width || mouseY <= 0 || mouseY >= canvas.height) {
                return; // Mouse is outside canvas
            }

            // Check if hovering over a tower - don't show preview
            const hoverTower = towers.find(tower =>
                Math.sqrt((tower.x - mouseX) ** 2 + (tower.y - mouseY) ** 2) < 30
            );

            if (hoverTower) {
                return; // Don't show preview when hovering over towers
            }

            const towerType = towerTypes[selectedTowerType];
            const canPlace = canPlaceTower(mouseX, mouseY);
            const canAfford = canAffordTower(selectedTowerType); // Determine preview colors based on validity
            let towerAlpha = 0.8;
            let towerColor = towerType.color;
            let rangeStroke, rangeFill;

            if (!canPlace) {
                // Red tint for invalid placement
                towerColor = '#FF4444';
                rangeStroke = 'rgba(255, 68, 68, 0.8)';
                rangeFill = 'rgba(255, 68, 68, 0.1)';
                towerAlpha = 0.6;
            } else if (!canAfford) {
                // Gray tint for can't afford
                towerColor = '#999999';
                rangeStroke = 'rgba(153, 153, 153, 0.6)';
                rangeFill = 'rgba(153, 153, 153, 0.1)';
                towerAlpha = 0.5;
            } else {
                // Green tint for valid placement
                rangeStroke = 'rgba(76, 175, 80, 0.8)';
                rangeFill = 'rgba(76, 175, 80, 0.15)';
            }

            // Draw range circle first (behind tower)
            ctx.strokeStyle = rangeStroke;
            ctx.fillStyle = rangeFill;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            ctx.arc(mouseX, mouseY, towerType.range, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw preview tower
            ctx.globalAlpha = towerAlpha;
            ctx.fillStyle = towerColor;
            ctx.fillRect(mouseX - 20, mouseY - 20, 40, 40);

            // Draw tower border
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = canPlace && canAfford ? '#333' : '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(mouseX - 20, mouseY - 20, 40, 40);

            // Draw tower type indicator
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            const typeChar = selectedTowerType.charAt(0).toUpperCase();
            ctx.strokeText(typeChar, mouseX, mouseY + 4);
            ctx.fillText(typeChar, mouseX, mouseY + 4);

            // Draw cost indicator
            ctx.fillStyle = canAfford ? '#00AA00' : '#FF0000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.strokeText(`$${towerType.cost}`, mouseX, mouseY - 35);
            ctx.fillText(`$${towerType.cost}`, mouseX, mouseY - 35);

            // Draw validity text
            if (!canPlace) {
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 12px Arial';
                ctx.strokeText('Cannot place here', mouseX, mouseY + 50);
                ctx.fillText('Cannot place here', mouseX, mouseY + 50);
            } else if (!canAfford) {
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 12px Arial';
                ctx.strokeText('Not enough money', mouseX, mouseY + 50);
                ctx.fillText('Not enough money', mouseX, mouseY + 50);
            }
        }

        function updateUI() {
            const config = gameModes[currentGameMode];

            // Update overlay stats
            document.getElementById('lives').textContent = config.infiniteLives ? '‚àû' : lives;
            document.getElementById('money').textContent = config.infiniteMoney ? '‚àû' : money;

            // Update wave display
            const maxWaveText = config.maxWaves === Infinity ? '‚àû' : config.maxWaves;
            document.getElementById('current-wave').textContent = currentWave + '/' + maxWaveText;

            document.getElementById('score').textContent = score;
            document.getElementById('enemies-remaining-overlay').textContent = enemies.length;

            // Update wave status
            const statusElement = document.getElementById('wave-status-text');
            if (waveInProgress) {
                if (gameState === 'playing') {
                    statusElement.textContent = 'In Progress';
                    statusElement.style.color = '#FF6B6B';
                } else if (gameState === 'paused') {
                    statusElement.textContent = 'Paused';
                    statusElement.style.color = '#FFD93D';
                }
            } else if (gameState === 'wave-break') {
                const elapsed = Date.now() - waveBreakStartTime;
                const remaining = Math.max(0, Math.ceil((config.waveBreakDuration - elapsed) / 1000));
                if (currentGameMode === 'survival') {
                    statusElement.textContent = `Next wave in ${remaining}s`;
                } else {
                    statusElement.textContent = `Break: ${remaining}s`;
                }
                statusElement.style.color = '#FFD93D';
            } else {
                statusElement.textContent = 'Ready';
                statusElement.style.color = '#6BCF7F';
            }

            // Update tower button states for both old and new buttons
            document.querySelectorAll('.tower-btn, .tower-overlay-btn').forEach(btn => {
                const type = btn.dataset.tower;
                if (type) {
                    const cost = towerTypes[type].cost;

                    if (money < cost) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });

            // Update start wave button
            const startWaveBtn = document.getElementById('start-wave-btn');
            if (gameState === 'wave-break' && currentGameMode !== 'survival') {
                startWaveBtn.disabled = false;
                startWaveBtn.textContent = 'Start Next Wave (Space)';
            } else if (gameState === 'building') {
                startWaveBtn.disabled = false;
                startWaveBtn.textContent = 'Start Wave (Space)';
            } else if (gameState === 'wave-break' && currentGameMode === 'survival') {
                startWaveBtn.disabled = true;
                startWaveBtn.textContent = 'Auto-starting...';
            } else {
                startWaveBtn.disabled = true;
                startWaveBtn.textContent = 'Start Wave (Space)';
            }

            // Update upgrade buttons if a tower is selected
            if (selectedTower) {
                updateUpgradeButtonsOverlay(selectedTower);
            }
        }

        function updateWavePreview() {
            const gameConfig = gameModes[currentGameMode];
            document.getElementById('wave-number').textContent = currentWave;
            const config = getWaveConfig(currentWave);

            const enemiesDiv = document.getElementById('wave-enemies');
            enemiesDiv.innerHTML = '';

            // Add game mode indicator
            const modeSpan = document.createElement('div');
            modeSpan.style.cssText = 'font-size: 0.8em; color: #FFD700; margin-bottom: 5px;';
            modeSpan.textContent = `${gameConfig.name} Mode`;
            enemiesDiv.appendChild(modeSpan);

            // Count enemy types
            const enemyCounts = {};
            config.enemies.forEach(type => {
                enemyCounts[type] = (enemyCounts[type] || 0) + Math.ceil(config.totalEnemies / config.enemies.length);
            });

            // Display enemy types
            Object.entries(enemyCounts).forEach(([type, count]) => {
                const span = document.createElement('span');
                span.className = `enemy-type enemy-${type}`;
                span.textContent = `${enemyTypes[type].name} x${count}`;
                enemiesDiv.appendChild(span);
            });

            document.getElementById('enemies-remaining').textContent = config.totalEnemies;
            document.getElementById('enemies-remaining-overlay').textContent = config.totalEnemies;
        }

        function upgradeTower(upgradeType) {
            if (!selectedTower) return;

            const tower = selectedTower;
            const config = upgradeConfig[upgradeType];
            let cost, upgradeCount;

            switch (upgradeType) {
                case 'damage':
                    upgradeCount = tower.damageUpgrades;
                    break;
                case 'range':
                    upgradeCount = tower.rangeUpgrades;
                    break;
                case 'speed':
                    upgradeCount = tower.speedUpgrades;
                    break;
            }

            cost = Math.round(config.baseCost * Math.pow(config.costMultiplier, upgradeCount));

            const gameConfig = gameModes[currentGameMode];
            if (!gameConfig.infiniteMoney && money < cost) {
                return;
            }

            // Deduct money (unless infinite money mode)
            if (!gameConfig.infiniteMoney) {
                money -= cost;
                tower.totalInvested += cost;
            }
            score += 5;

            // Apply upgrade
            switch (upgradeType) {
                case 'damage':
                    tower.damageUpgrades++;
                    break;
                case 'range':
                    tower.rangeUpgrades++;
                    break;
                case 'speed':
                    tower.speedUpgrades++;
                    const newFireRate = tower.fireRate * Math.pow(config.bonus, tower.speedUpgrades);
                    break;
            }

            // Update UI
            if (selectedTower === tower) {
                selectTower(tower); // Refresh the selection panel/overlay
            }
            updateUI();
        }

        function sellTower() {
            if (!selectedTower) return;

            const sellValue = Math.round(selectedTower.totalInvested * 0.7);
            money += sellValue;
            score += Math.round(sellValue * 0.5);

            // Remove tower from array
            const towerIndex = towers.indexOf(selectedTower);
            if (towerIndex > -1) {
                towers.splice(towerIndex, 1);
            }

            // Hide upgrade overlay
            document.getElementById('tower-upgrade-overlay').style.display = 'none';
            selectedTower = null;

            // Return to preview mode
            showPreview = true;
            canvas.classList.add('preview-mode');

            updateUI();
            drawGame();
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pause-btn').textContent = 'Resume';
            } else if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pause-btn').textContent = 'Pause';
            }
        }

        function cycleGameSpeed() {
            // Cycle to next speed option
            gameSpeedIndex = (gameSpeedIndex + 1) % gameSpeedOptions.length;
            gameSpeed = gameSpeedOptions[gameSpeedIndex];

            // Update button text
            document.getElementById('speed-btn').textContent = `Speed: ${gameSpeed}x`;
        }

        function restartGame() {
            showGameModeSelection();
        }

        function showGameEndScreen(victory = false) {
            if (victory) {
                document.getElementById('waves-completed').textContent = 'All waves completed!';
                document.getElementById('game-over-title').textContent = 'Victory!';
            } else {
                document.getElementById('waves-completed').textContent = `Waves Completed: ${currentWave - 1}/20`;
                document.getElementById('game-over-title').textContent = 'Game Over';
            }
            document.getElementById('game-over-screen').style.display = 'block';
            document.getElementById('final-score').textContent = `Final Score: ${score}`;

            document.getElementById('tower-upgrade-overlay').style.display = 'none';
            document.getElementById('tower-selection-overlay').style.display = 'none';
            document.getElementById('enemy-spawn-overlay').style.display = 'none';
        }

        // Start game loop
        function gameLoop() {
            updateGame();

            // Always redraw if preview is active to keep it responsive
            if (showPreview && !selectedTower) {
                drawGame();
            }

            requestAnimationFrame(gameLoop);
        }

        // Initialize and start game
        initGame();
        gameLoop();
    </script>
</body>

</html>
