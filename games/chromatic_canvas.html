<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Chromatic Canvas</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        #canvas {
            border: 8px solid #8B4513;
            border-radius: 12px;
            background: linear-gradient(135deg, #FFF8DC 0%, #F5F5DC 100%);
            display: block;
            margin: 0 auto;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.3) 1px, transparent 1px),
                radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
            background-size: 30px 30px, 45px 45px;
        }

        #game-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        #controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        #stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            font-weight: bold;
        }

        .stat-item {
            padding: 8px 16px;
            background: linear-gradient(135deg, #E8E8E8 0%, #F5F5F5 100%);
            border-radius: 8px;
            font-size: 0.9em;
            border: 1px solid #DDD;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #color-palette {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #8B4513;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .color-option {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            margin: 5px;
            cursor: pointer;
            border: 3px solid #FFF;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            display: inline-block;
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .color-option.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none !important;
        }

        .color-option.clear-option {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 3px dashed #dc3545 !important;
        }

        .color-option.clear-option:hover {
            background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%);
            border-color: #c82333 !important;
        }

        #message {
            font-size: 1.2em;
            height: 60px;
            margin: 15px 0;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #F0F8FF 0%, #E6F3FF 100%);
            border-radius: 8px;
            border-left: 4px solid #4A90E2;
            padding: 0 20px;
        }

        .victory {
            background: linear-gradient(135deg, #E8F5E8 0%, #D4EDDA 100%);
            border-left-color: #28a745;
            color: #155724;
        }

        .error {
            background: linear-gradient(135deg, #FFF0F0 0%, #F8D7DA 100%);
            border-left-color: #dc3545;
            color: #721c24;
        }

        .info {
            color: #0c5460;
        }

        .game-btn {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
            color: white;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .game-btn:active {
            transform: translateY(0);
        }

        #level-info {
            background: linear-gradient(135deg, #F8F9FA 0%, #E9ECEF 100%);
            border: 2px solid #DEE2E6;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .color-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 5px;
            border: 2px solid #FFF;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #instructions {
            font-size: 0.9em;
            color: #666;
            margin-top: 15px;
            line-height: 1.5;
            text-align: center;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>

<body>
    <a href="../index.html" title="Back to Home" class="home-link">
        <svg width="28" height="28" viewBox="0 0 24 24">
            <path d="M15 18l-6-6 6-6" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span>Home</span>
    </a>
    <h1>ðŸŽ¨ Chromatic Canvas</h1>
    <div id="game-container">
        <div id="game">
            <div id="controls">
                <label for="level-select">Level:</label>
                <select id="level-select" onchange="changeLevel()">
                    <option value="1">Level 1</option>
                    <option value="2">Level 2</option>
                    <option value="3">Level 3</option>
                    <option value="4">Level 4</option>
                    <option value="5">Level 5</option>
                    <option value="6">Level 6</option>
                </select>
                <button class="game-btn" onclick="newLevel()">New Canvas</button>
                <button class="game-btn" onclick="clearCanvas()">Clear Colors</button>
                <button class="game-btn" onclick="showHint()">ðŸ’¡ Hint</button>
            </div>

            <div id="stats">
                <div class="stat-item">Level: <span id="current-level">1</span></div>
                <div class="stat-item">Colors Used: <span id="colors-used">0</span></div>
                <div class="stat-item">Target: <span id="target-colors">2</span> colors</div>
                <div class="stat-item">Efficiency: <span id="efficiency">0%</span></div>
            </div>

            <div id="message">Click on a region to start coloring your masterpiece!</div>

            <canvas id="canvas" width="600" height="600"></canvas>

            <div id="color-palette">
                <!-- Colors will be added dynamically -->
            </div>
        </div>

        <div id="rules">
            <h3>Chromatic Canvas Rules</h3>

            <h4>How to Play</h4>
            <ul>
                <li><strong>Goal:</strong> Color all regions using as few colors as possible</li>
                <li><strong>Rule:</strong> Adjacent regions cannot share the same color</li>
                <li><strong>Click:</strong> Select a region to open the color palette</li>
                <li><strong>Win:</strong> Complete the canvas with optimal color count</li>
            </ul>

            <h4>Graph Theory</h4>
            <ul>
                <li><strong>Vertices:</strong> Each colored region represents a graph vertex</li>
                <li><strong>Edges:</strong> Shared borders create graph connections</li>
                <li><strong>Coloring:</strong> Classic graph coloring problem visualization</li>
                <li><strong>Planar:</strong> These graphs follow the four-color theorem</li>
            </ul>

            <div class="strategy">
                <strong>Strategy Tips:</strong>
                <ul>
                    <li>Start with regions that have the most neighbors</li>
                    <li>Try to reuse colors for non-adjacent regions</li>
                    <li>Look for patterns like cycles and trees</li>
                    <li>Use hints when you're stuck on optimization</li>
                </ul>
            </div>
        </div>
    </div>    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorPalette = document.getElementById('color-palette');

        // Game state
        let currentLevel = 1;
        let regions = [];
        let selectedRegion = null;
        let colorsUsed = 0;
        let targetColors = 2;
        let graph = {}; // adjacency list representation
        let regionColors = {}; // region_id -> color mapping

        // Available colors - lighter core colors
        const colors = [
            '#FF6B6B', // Light Red
            '#51CF66', // Light Green
            '#74C0FC', // Light Blue
            '#FFE066', // Light Yellow
            '#ADB5BD', // Light Gray
            '#FFAA5A', // Light Orange
            '#B197FC', // Light Purple
            '#66D9EF', // Light Cyan
            '#FF8CC8', // Light Pink
            '#8CE99A'  // Light Lime
        ];

        // Level definitions
        const levels = {
            1: { targetColors: 4, regions: 12 },
            2: { targetColors: 4, regions: 18 },
            3: { targetColors: 3, regions: 24 },
            4: { targetColors: 4, regions: 30 },
            5: { targetColors: 4, regions: 36 },
            6: { targetColors: 4, regions: 42 }
        };

        function init() {
            generateLevel(currentLevel);
            setupEventListeners();
            updateStats();
            showMessage("Welcome to Chromatic Canvas! Click on a region to start coloring.", "info");
        }

        function setupEventListeners() {
            canvas.addEventListener('click', handleCanvasClick);
            document.addEventListener('click', handleDocumentClick);
        }

        function generateLevel(levelNum) {
            const level = levels[levelNum];
            targetColors = level.targetColors;
            regions = [];
            graph = {};
            regionColors = {};
            colorsUsed = 0;

            generateSimpleVoronoi(level.regions);
            render();
        }

        // Simple and reliable Voronoi-like region generation
        function generateSimpleVoronoi(numRegions) {
            const width = canvas.width;
            const height = canvas.height;

            regions = [];
            graph = {};

            console.log(`Generating ${numRegions} regions`);

            // Use recursive subdivision to guarantee coverage and adjacency
            createSubdividedRegions(numRegions, width, height);

            console.log(`Generated ${regions.length} clean regions`);
        }

        function createSubdividedRegions(numRegions, width, height) {
            // Start with the entire canvas as one region
            const initialRegion = {
                x: 0,
                y: 0,
                width: width,
                height: height,
                id: 0
            };

            let rectangles = [initialRegion];

            // Recursively subdivide until we have enough regions
            while (rectangles.length < numRegions) {
                rectangles = subdivideRegions(rectangles);

                // Prevent infinite loop
                if (rectangles.length >= numRegions) break;
            }

            // If we have too many rectangles, stop subdividing earlier
            // This approach prevents the need for complex merging

            // Convert rectangles to our region format
            regions = [];
            rectangles.forEach((rect, index) => {
                // Ensure rectangles cover exactly to canvas bounds
                const x1 = Math.max(0, Math.floor(rect.x));
                const y1 = Math.max(0, Math.floor(rect.y));
                const x2 = Math.min(width, Math.ceil(rect.x + rect.width));
                const y2 = Math.min(height, Math.ceil(rect.y + rect.height));

                regions.push({
                    id: index,
                    points: [
                        { x: x1, y: y1 },
                        { x: x2, y: y1 },
                        { x: x2, y: y2 },
                        { x: x1, y: y2 }
                    ],
                    color: null
                });
            });

            // Build perfect adjacency graph
            buildPerfectAdjacencyGraph();
        }

        function mergeSmallestRectangles(rectangles) {
            // Find the smallest rectangle
            let smallestIndex = 0;
            let smallestArea = rectangles[0].width * rectangles[0].height;

            rectangles.forEach((rect, index) => {
                const area = rect.width * rect.height;
                if (area < smallestArea) {
                    smallestArea = area;
                    smallestIndex = index;
                }
            });

            // Find an adjacent rectangle to merge with
            const smallestRect = rectangles[smallestIndex];
            let mergeCandidate = null;
            let mergeCandidateIndex = -1;

            rectangles.forEach((rect, index) => {
                if (index === smallestIndex) return;

                // Check if rectangles are adjacent
                if (areRectanglesAdjacent(smallestRect, rect)) {
                    if (!mergeCandidate || (rect.width * rect.height) < (mergeCandidate.width * mergeCandidate.height)) {
                        mergeCandidate = rect;
                        mergeCandidateIndex = index;
                    }
                }
            });

            // Merge the rectangles if possible
            if (mergeCandidate) {
                const merged = mergeRectangles(smallestRect, mergeCandidate);
                const newRectangles = rectangles.filter((_, index) => index !== smallestIndex && index !== mergeCandidateIndex);
                newRectangles.push(merged);
                return newRectangles;
            }

            // If no merge possible, just remove the smallest (shouldn't happen with proper adjacency)
            return rectangles.filter((_, index) => index !== smallestIndex);
        }

        function areRectanglesAdjacent(rect1, rect2) {
            // Check if rectangles share an edge
            const shareVertical = (rect1.x + rect1.width === rect2.x || rect2.x + rect2.width === rect1.x) &&
                                 !(rect1.y >= rect2.y + rect2.height || rect2.y >= rect1.y + rect1.height);

            const shareHorizontal = (rect1.y + rect1.height === rect2.y || rect2.y + rect2.height === rect1.y) &&
                                   !(rect1.x >= rect2.x + rect2.width || rect2.x >= rect1.x + rect1.width);

            return shareVertical || shareHorizontal;
        }

        function mergeRectangles(rect1, rect2) {
            // Create bounding box that contains both rectangles
            const minX = Math.min(rect1.x, rect2.x);
            const minY = Math.min(rect1.y, rect2.y);
            const maxX = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
            const maxY = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
                id: Math.min(rect1.id, rect2.id)
            };
        }

        function subdivideRegions(rectangles) {
            const newRectangles = [];

            rectangles.forEach(rect => {
                // Calculate aspect ratio to determine if rectangle needs balancing
                const aspectRatio = rect.width / rect.height;
                const isVeryUnbalanced = aspectRatio > 2.5 || aspectRatio < 0.4;
                const isSomewhatUnbalanced = aspectRatio > 1.8 || aspectRatio < 0.55;

                // Subdivide if rectangle is large enough OR very unbalanced
                const shouldSubdivide = (rect.width > 30 && rect.height > 30) ||
                                       (isVeryUnbalanced && rect.width > 20 && rect.height > 20) ||
                                       (isSomewhatUnbalanced && rect.width > 40 && rect.height > 40);

                if (shouldSubdivide) {
                    const subdivided = subdivideRectangle(rect);
                    newRectangles.push(...subdivided);
                } else {
                    newRectangles.push(rect);
                }
            });

            // If no subdivision happened, force subdivide the largest
            if (newRectangles.length === rectangles.length) {
                let largest = rectangles[0];
                let largestIndex = 0;

                rectangles.forEach((rect, index) => {
                    if (rect.width * rect.height > largest.width * largest.height) {
                        largest = rect;
                        largestIndex = index;
                    }
                });

                const subdivided = subdivideRectangle(largest);
                newRectangles.splice(largestIndex, 1, ...subdivided);
            }

            return newRectangles;
        }

        function subdivideRectangle(rect) {
            const { x, y, width, height } = rect;

            // Calculate aspect ratio to determine how unbalanced the rectangle is
            const aspectRatio = width / height;

            // Always split along the longer dimension to balance aspect ratios
            let splitVertically = width > height;

            // // Add some randomness based on style, but prefer balancing
            // if (style === 'structured') {
            //     // Pure aspect ratio balancing
            //     splitVertically = width > height;
            // } else if (style === 'organic' || style === 'artistic') {
            //     // 80% chance to balance, 20% random for variety
            //     if (Math.random() < 0.8) {
            //         splitVertically = width > height;
            //     } else {
            //         splitVertically = Math.random() > 0.5;
            //     }
            // } else {
            //     // Default: mostly balance with some variation
            //     if (aspectRatio > 1.5 || aspectRatio < 0.67) {
            //         // Very unbalanced - force balance
            //         splitVertically = width > height;
            //     } else {
            //         // Somewhat balanced - allow some randomness
            //         splitVertically = width > height ? (Math.random() > 0.3) : (Math.random() < 0.3);
            //     }
            // }

            if (splitVertically) {
                // Split vertically - aim for more balanced pieces
                // Use 40-60% split range for better balance
                const minRatio = 0.35;
                const maxRatio = 0.65;
                const splitRatio = minRatio + Math.random() * (maxRatio - minRatio);
                const splitPos = Math.floor(width * splitRatio);

                return [
                    { x: x, y: y, width: splitPos, height: height, id: rect.id },
                    { x: x + splitPos, y: y, width: width - splitPos, height: height, id: rect.id + 1000 }
                ];
            } else {
                // Split horizontally - aim for more balanced pieces
                const minRatio = 0.35;
                const maxRatio = 0.65;
                const splitRatio = minRatio + Math.random() * (maxRatio - minRatio);
                const splitPos = Math.floor(height * splitRatio);

                return [
                    { x: x, y: y, width: width, height: splitPos, id: rect.id },
                    { x: x, y: y + splitPos, width: width, height: height - splitPos, id: rect.id + 1000 }
                ];
            }
        }

        function buildPerfectAdjacencyGraph() {
            graph = {};

            // Initialize graph
            regions.forEach((region, index) => {
                graph[index] = [];
            });

            // Check adjacency for each pair of regions
            for (let i = 0; i < regions.length; i++) {
                for (let j = i + 1; j < regions.length; j++) {
                    if (rectanglesAreAdjacent(regions[i].points, regions[j].points)) {
                        graph[i].push(j);
                        graph[j].push(i);
                    }
                }
            }
        }

        function rectanglesAreAdjacent(points1, points2) {
            // Convert points to bounds
            const bounds1 = {
                left: points1[0].x,
                right: points1[1].x,
                top: points1[0].y,
                bottom: points1[2].y
            };

            const bounds2 = {
                left: points2[0].x,
                right: points2[1].x,
                top: points2[0].y,
                bottom: points2[2].y
            };

            // Check if they share an edge (not just touching at corner)
            const shareVerticalEdge = (
                (Math.abs(bounds1.right - bounds2.left) < 1 || Math.abs(bounds1.left - bounds2.right) < 1) &&
                !(bounds1.bottom <= bounds2.top || bounds1.top >= bounds2.bottom)
            );

            const shareHorizontalEdge = (
                (Math.abs(bounds1.bottom - bounds2.top) < 1 || Math.abs(bounds1.top - bounds2.bottom) < 1) &&
                !(bounds1.right <= bounds2.left || bounds1.left >= bounds2.right)
            );

            return shareVerticalEdge || shareHorizontalEdge;
        }

        function createFallbackRegions(numRegions) {
            const width = canvas.width;
            const height = canvas.height;

            // Simple grid fallback
            const cols = Math.ceil(Math.sqrt(numRegions));
            const rows = Math.ceil(numRegions / cols);
            const cellW = width / cols;
            const cellH = height / rows;

            for (let i = 0; i < numRegions; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;

                const x = col * cellW;
                const y = row * cellH;

                regions.push({
                    id: i,
                    points: [
                        { x: x, y: y },
                        { x: x + cellW, y: y },
                        { x: x + cellW, y: y + cellH },
                        { x: x, y: y + cellH }
                    ],
                    color: null
                });

                graph[i] = [];
                // Connect to adjacent cells
                if (col > 0) graph[i].push(i - 1);
                if (col < cols - 1 && i + 1 < numRegions) graph[i].push(i + 1);
                if (row > 0) graph[i].push(i - cols);
                if (row < rows - 1 && i + cols < numRegions) graph[i].push(i + cols);
            }
        }

        function getRegionCenter(region) {
            const sumX = region.points.reduce((sum, p) => sum + p.x, 0);
            const sumY = region.points.reduce((sum, p) => sum + p.y, 0);
            return {
                x: sumX / region.points.length,
                y: sumY / region.points.length
            };
        }        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check which region was clicked
            for (const region of regions) {
                if (isPointInRegion(x, y, region.points)) {
                    selectedRegion = region;
                    showColorPalette(e.clientX, e.clientY);
                    render();
                    return;
                }
            }

            hideColorPalette();
        }

        function handleDocumentClick(e) {
            if (!colorPalette.contains(e.target) && e.target !== canvas) {
                hideColorPalette();
            }
        }

        function isPointInRegion(x, y, points) {
            let inside = false;
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                if (((points[i].y > y) !== (points[j].y > y)) &&
                    (x < (points[j].x - points[i].x) * (y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function showColorPalette(x, y) {
            colorPalette.innerHTML = '';

            // Add clear option if the region currently has a color
            if (selectedRegion.color) {
                const clearDiv = document.createElement('div');
                clearDiv.className = 'color-option clear-option';
                clearDiv.style.backgroundColor = '#f8f9fa';
                clearDiv.style.border = '3px dashed #dc3545';
                clearDiv.style.position = 'relative';
                clearDiv.innerHTML = '<span style="color: #dc3545; font-weight: bold; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px;">âœ•</span>';
                clearDiv.title = 'Clear color';
                clearDiv.onclick = () => clearRegionColor();
                colorPalette.appendChild(clearDiv);
            }

            // Get available colors (not conflicting with adjacent regions)
            const availableColors = getAvailableColors(selectedRegion.id);

            colors.slice(0, 6).forEach((color, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-option';
                colorDiv.style.backgroundColor = color;

                if (!availableColors.includes(color)) {
                    colorDiv.classList.add('disabled');
                } else {
                    colorDiv.onclick = () => selectColor(color);
                }

                colorPalette.appendChild(colorDiv);
            });

            colorPalette.style.display = 'block';
            colorPalette.style.left = Math.min(x, window.innerWidth - 200) + 'px';
            colorPalette.style.top = Math.min(y, window.innerHeight - 150) + 'px';
        }

        function hideColorPalette() {
            colorPalette.style.display = 'none';
            selectedRegion = null;
            render();
        }

        function getAvailableColors(regionId) {
            const usedColors = new Set();
            const adjacentRegions = graph[regionId] || [];

            adjacentRegions.forEach(adjId => {
                if (regionColors[adjId]) {
                    usedColors.add(regionColors[adjId]);
                }
            });

            return colors.filter(color => !usedColors.has(color));
        }

        function selectColor(color) {
            if (selectedRegion) {
                const oldColor = selectedRegion.color;
                selectedRegion.color = color;
                regionColors[selectedRegion.id] = color;

                if (!oldColor) {
                    // New color added
                    const usedColorsSet = new Set(Object.values(regionColors));
                    colorsUsed = usedColorsSet.size;
                }

                updateStats();
                checkWinCondition();
                hideColorPalette();
                render();

                showMessage(`Colored region with ${getColorName(color)}!`, "info");
            }
        }

        function clearRegionColor() {
            if (selectedRegion && selectedRegion.color) {
                const clearedColor = selectedRegion.color;
                selectedRegion.color = null;
                delete regionColors[selectedRegion.id];

                // Recalculate colors used
                const usedColorsSet = new Set(Object.values(regionColors));
                colorsUsed = usedColorsSet.size;

                updateStats();
                hideColorPalette();
                render();

                showMessage(`Cleared ${getColorName(clearedColor)} from region!`, "info");
            }
        }

        function getColorName(color) {
            const colorNames = {
                '#FF6B6B': 'Coral Red',
                '#4ECDC4': 'Turquoise',
                '#45B7D1': 'Sky Blue',
                '#96CEB4': 'Mint Green',
                '#FFEAA7': 'Warm Yellow',
                '#DDA0DD': 'Plum'
            };
            return colorNames[color] || 'Unknown Color';
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw regions
            regions.forEach(region => {
                // Fill region
                ctx.beginPath();
                ctx.moveTo(region.points[0].x, region.points[0].y);

                for (let i = 1; i < region.points.length; i++) {
                    ctx.lineTo(region.points[i].x, region.points[i].y);
                }
                ctx.closePath();

                // Fill with color or default
                if (region.color) {
                    ctx.fillStyle = region.color;
                } else {
                    ctx.fillStyle = '#F5F5DC';
                }
                ctx.fill();

                // Draw border
                ctx.strokeStyle = selectedRegion === region ? '#FF4500' : '#8B4513';
                ctx.lineWidth = selectedRegion === region ? 4 : 2;
                ctx.stroke();

                // Add subtle shadow for uncolored regions
                if (!region.color) {
                    ctx.save();
                    ctx.strokeStyle = '#DDD';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        function updateStats() {
            document.getElementById('current-level').textContent = currentLevel;
            document.getElementById('colors-used').textContent = colorsUsed;
            document.getElementById('target-colors').textContent = targetColors;

            const efficiency = colorsUsed > 0 ? Math.round((targetColors / colorsUsed) * 100) : 0;
            document.getElementById('efficiency').textContent = efficiency + '%';
        }

        function checkWinCondition() {
            // Check if all regions are colored
            const allColored = regions.every(region => region.color !== null);

            if (allColored) {
                // Check if coloring is valid
                let isValid = true;
                for (const [regionId, adjacentIds] of Object.entries(graph)) {
                    const regionColor = regionColors[regionId];
                    for (const adjId of adjacentIds) {
                        if (regionColors[adjId] === regionColor) {
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) break;
                }

                if (isValid) {
                    const efficiency = Math.round((targetColors / colorsUsed) * 100);
                    let message = `ðŸŽ‰ Masterpiece Complete! Used ${colorsUsed} colors (${efficiency}% efficiency)`;

                    if (colorsUsed === targetColors) {
                        message += " - Perfect optimal solution! ðŸŒŸ";
                    } else if (colorsUsed === targetColors + 1) {
                        message += " - Excellent job! ðŸ‘";
                    }

                    showMessage(message, "victory");
                } else {
                    showMessage("âŒ Invalid coloring! Adjacent regions can't share colors.", "error");
                }
            }
        }

        function changeLevel() {
            currentLevel = parseInt(document.getElementById('level-select').value);
            generateLevel(currentLevel);
            updateStats();
            showMessage(`Level ${currentLevel} - Let's create art!`, "info");
        }

        function newLevel() {
            generateLevel(currentLevel);
            updateStats();
            showMessage("Fresh canvas ready! Start your artistic journey.", "info");
        }

        function clearCanvas() {
            regions.forEach(region => {
                region.color = null;
            });
            regionColors = {};
            colorsUsed = 0;
            updateStats();
            render();
            showMessage("Canvas cleared! Ready for a new masterpiece.", "info");
        }

        function showHint() {
            if (colorsUsed === 0) {
                showMessage("ðŸ’¡ Hint: Start with the region that has the most neighbors!", "info");
            } else {
                // Find a region that can be colored with existing colors
                for (const region of regions) {
                    if (!region.color) {
                        const availableColors = getAvailableColors(region.id);
                        const usedColors = new Set(Object.values(regionColors));
                        const reusableColors = availableColors.filter(color => usedColors.has(color));

                        if (reusableColors.length > 0) {
                            showMessage(`ðŸ’¡ Hint: Try reusing ${getColorName(reusableColors[0])} for one of the uncolored regions!`, "info");
                            return;
                        }
                    }
                }
                showMessage("ðŸ’¡ Hint: Look for regions that can share colors without being adjacent!", "info");
            }
        }

        function showMessage(text, type = "") {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = type;
        }

        // Initialize game when page loads
        window.onload = function() {
            init();
        };
    </script>
</body>
</html>
