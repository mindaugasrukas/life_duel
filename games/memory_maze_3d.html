<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Memory Maze</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        #canvas {
            border: 2px solid #333;
            background: #000;
            display: block;
            margin: 0 auto;
        }

        #controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        #stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            font-weight: bold;
        }

        .stat-item {
            padding: 8px 16px;
            background: #e8e8e8;
            border-radius: 6px;
            font-size: 0.9em;
        }

        #message {
            font-size: 1.2em;
            height: 50px;
            margin: 15px 0;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .victory {
            color: #2e7d32;
        }

        .info {
            color: #1976d2;
        }

        #instructions {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
            text-align: center;
        }

        #compass {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
            font-weight: bold;
        }

        .compass-indicator {
            width: 40px;
            height: 40px;
            border: 2px solid #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
        }

        .compass-arrow {
            font-size: 20px;
            transform-origin: center;
            transition: transform 0.3s ease;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
            width: 150px;
            margin: 0 auto;
        }

        .movement-btn {
            padding: 10px;
            font-size: 1.2em;
            border: 2px solid #333;
            background: #f0f0f0;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s;
        }

        .movement-btn:hover {
            background: #ddd;
        }

        .movement-btn:active {
            background: #bbb;
        }

        .movement-btn:nth-child(2) { /* Forward */
            grid-column: 2;
            grid-row: 1;
        }

        .movement-btn:nth-child(1) { /* Turn Left */
            grid-column: 1;
            grid-row: 2;
        }

        .movement-btn:nth-child(3) { /* Turn Right */
            grid-column: 3;
            grid-row: 2;
        }

        .movement-btn:nth-child(4) { /* Backward */
            grid-column: 2;
            grid-row: 3;
        }

        #difficulty {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <a href="../index.html" title="Back to Home" class="home-link">
        <svg width="28" height="28" viewBox="0 0 24 24">
            <path d="M15 18l-6-6 6-6" stroke="#333" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span>Home</span>
    </a>

    <h1>3D Memory Maze</h1>
    <div id="game-container">
        <div id="game">
            <div id="controls">
                <label for="difficulty">Difficulty:</label>
                <select id="difficulty" onchange="changeDifficulty()">
                    <option value="beginner">Beginner (21x21 maze)</option>
                    <option value="intermediate" selected>Intermediate (25x25 maze)</option>
                    <option value="expert">Expert (31x31 maze)</option>
                    <option value="master">Master (39x39 maze)</option>
                </select>
                <button onclick="newGame()">New Maze</button>
                <button onclick="resetGame(); showMessage('Position reset! Try again.', 'info');">Reset Position</button>
            </div>

        <div id="stats">
            <div class="stat-item">Steps: <span id="steps">0</span></div>
            <div class="stat-item">Time: <span id="time">0:00</span></div>
        </div>

        <div id="compass">
            <span>Facing:</span>
            <div class="compass-indicator">
                <div class="compass-arrow" id="compass-arrow">↑</div>
            </div>
            <span id="direction-text">North</span>
        </div>

        <div id="message"></div>
        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="movement-controls">
            <button class="movement-btn" onclick="turnLeft()">↺</button>
            <button class="movement-btn" onclick="moveForward()">↑</button>
            <button class="movement-btn" onclick="turnRight()">↻</button>
            <button class="movement-btn" onclick="moveBackward()">↓</button>
        </div>

            <div id="instructions">
                <strong>Controls:</strong> Use movement buttons or arrow keys + A/D to turn.<br>
                <strong>Goal:</strong> Navigate to the goal using only your first-person view - build a mental map!<br>
                <strong>Challenge:</strong> No mini-map - rely on memory and spatial orientation.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let maze = [];
        let mazeWidth = 25;
        let mazeHeight = 25;
        let playerX = 1.5; // Always start at center of a cell
        let playerY = 1.5; // Always start at center of a cell
        let playerDir = 0; // 0=North, 1=East, 2=South, 3=West
        let goalX = mazeWidth - 2;
        let goalY = mazeHeight - 2;
        let steps = 0;
        let startTime = Date.now();
        let gameWon = false;

        // 3D rendering constants
        const SCREEN_WIDTH = canvas.width;
        const SCREEN_HEIGHT = canvas.height;
        const FOV = Math.PI / 2.3; // ~82 degrees - wider field of view
        const MAX_DEPTH = 12; // See further into the distance
        const WALL_HEIGHT = 200;

        // Direction vectors [dx, dy] for North, East, South, West
        const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
        const directionNames = ["North", "East", "South", "West"];
        const directionArrows = ["↑", "→", "↓", "←"];

        // Difficulty settings
        const difficulties = {
            beginner: { size: 21 },
            intermediate: { size: 25 },
            expert: { size: 31 },
            master: { size: 39 }
        };

        function init() {
            generateMaze();
            resetGame(); // This will set proper player position and direction
            showMessage("Navigate to the goal using first-person view! Use your memory to build a mental map.", "info");
        }

        function generateMaze() {
            // Initialize maze with walls
            maze = Array(mazeHeight).fill().map(() =>
                Array(mazeWidth).fill().map(() => ({ wall: true, visited: false }))
            );

            // Generate maze using recursive backtracking
            const stack = [];
            const visited = Array(mazeHeight).fill().map(() => Array(mazeWidth).fill(false));

            let currentX = 1;
            let currentY = 1;
            maze[currentY][currentX].wall = false;
            visited[currentY][currentX] = true;
            stack.push([currentX, currentY]);

            while (stack.length > 0) {
                const neighbors = getUnvisitedNeighbors(currentX, currentY, visited);

                if (neighbors.length > 0) {
                    const [nextX, nextY] = neighbors[Math.floor(Math.random() * neighbors.length)];

                    // Remove wall between current and next
                    maze[nextY][nextX].wall = false;
                    maze[currentY + (nextY - currentY) / 2][currentX + (nextX - currentX) / 2].wall = false;
                    visited[nextY][nextX] = true;
                    stack.push([nextX, nextY]);
                    currentX = nextX;
                    currentY = nextY;
                } else {
                    [currentX, currentY] = stack.pop();
                }
            }

            // Ensure goal is accessible
            maze[goalY][goalX].wall = false;
        }

        function getUnvisitedNeighbors(x, y, visited) {
            const neighbors = [];
            const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]];

            for (const [dx, dy] of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx > 0 && nx < mazeWidth - 1 && ny > 0 && ny < mazeHeight - 1 && !visited[ny][nx]) {
                    neighbors.push([nx, ny]);
                }
            }
            return neighbors;
        }

        function newGame() {
            generateMaze();
            resetGame();
        }

        function resetGame() {
            // Start from the maze generation starting point (1,1)
            let startX = 1;
            let startY = 1;

            // Ensure the starting cell is open (it should be from maze generation)
            maze[startY][startX].wall = false;

            // Find a direction that faces an open path instead of a wall
            playerDir = 0; // Default to North
            let foundOpenDirection = false;

            // Check all four directions to find one with an open path
            for (let dir = 0; dir < 4; dir++) {
                const [dx, dy] = directions[dir];
                const checkX = startX + dx;
                const checkY = startY + dy;

                // Check if this direction leads to an open cell
                if (checkX >= 0 && checkX < mazeWidth &&
                    checkY >= 0 && checkY < mazeHeight &&
                    maze[checkY] && maze[checkY][checkX] &&
                    !maze[checkY][checkX].wall) {
                    playerDir = dir;
                    foundOpenDirection = true;
                    break; // Found an open direction, use it
                }
            }

            // If no open direction found (shouldn't happen), force create one
            if (!foundOpenDirection) {
                console.log("No open direction found, forcing creation of path");
                // Try to open a path in each direction until one works
                for (let dir = 0; dir < 4; dir++) {
                    const [dx, dy] = directions[dir];
                    const checkX = startX + dx;
                    const checkY = startY + dy;

                    if (checkX > 0 && checkX < mazeWidth - 1 &&
                        checkY > 0 && checkY < mazeHeight - 1) {
                        // Force open this adjacent cell
                        maze[checkY][checkX].wall = false;
                        playerDir = dir;
                        foundOpenDirection = true;
                        break;
                    }
                }
            }

            // Place player in the CENTER of the cell (always at .5 coordinates)
            playerX = startX + 0.5;
            playerY = startY + 0.5;

            steps = 0;
            startTime = Date.now();
            gameWon = false;

            console.log(`Player placed at (${playerX}, ${playerY}) in cell (${startX}, ${startY}), facing ${directionNames[playerDir]} (${foundOpenDirection ? 'found' : 'forced'} open path)`);

            // Debug: Show the area around the starting position
            console.log("Area around starting position:");
            for (let dy = -1; dy <= 1; dy++) {
                let row = "";
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = startX + dx;
                    const checkY = startY + dy;
                    if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
                        if (dx === 0 && dy === 0) {
                            row += "P"; // Player position
                        } else if (maze[checkY][checkX].wall) {
                            row += "█";
                        } else {
                            row += ".";
                        }
                    } else {
                        row += " ";
                    }
                }
                console.log(`  ${row}`);
            }

            updateDisplay();
            render3D();
            updateStats();
        }

        function changeDifficulty() {
            const difficulty = document.getElementById('difficulty').value;
            const settings = difficulties[difficulty];
            mazeWidth = settings.size;
            mazeHeight = settings.size;
            goalX = mazeWidth - 2;
            goalY = mazeHeight - 2;
            newGame();
        }

        function moveForward() {
            if (gameWon) return;

            const [dx, dy] = directions[playerDir];
            // Calculate target cell coordinates (always move to center of adjacent cell)
            const currentCellX = Math.floor(playerX);
            const currentCellY = Math.floor(playerY);
            const targetCellX = currentCellX + dx;
            const targetCellY = currentCellY + dy;
            const newX = targetCellX + 0.5;
            const newY = targetCellY + 0.5;

            if (isValidMove(newX, newY)) {
                playerX = newX;
                playerY = newY;
                steps++;
                // Mark the cell as visited
                if (maze[targetCellY] && maze[targetCellY][targetCellX]) {
                    maze[targetCellY][targetCellX].visited = true;
                }
                checkWin();
                updateDisplay();
                render3D();
                updateStats();
            }
        }

        function moveBackward() {
            if (gameWon) return;

            const [dx, dy] = directions[playerDir];
            // Calculate target cell coordinates (always move to center of adjacent cell)
            const currentCellX = Math.floor(playerX);
            const currentCellY = Math.floor(playerY);
            const targetCellX = currentCellX - dx;
            const targetCellY = currentCellY - dy;
            const newX = targetCellX + 0.5;
            const newY = targetCellY + 0.5;

            if (isValidMove(newX, newY)) {
                playerX = newX;
                playerY = newY;
                steps++;
                // Mark the cell as visited
                if (maze[targetCellY] && maze[targetCellY][targetCellX]) {
                    maze[targetCellY][targetCellX].visited = true;
                }
                updateDisplay();
                render3D();
                updateStats();
            }
        }

        function turnLeft() {
            if (gameWon) return;
            playerDir = (playerDir + 3) % 4; // +3 is same as -1 in mod 4
            updateDisplay();
            render3D();
        }

        function turnRight() {
            if (gameWon) return;
            playerDir = (playerDir + 1) % 4;
            updateDisplay();
            render3D();
        }

        function isValidMove(x, y) {
            // Convert player position to grid coordinates
            const gridX = Math.floor(x);
            const gridY = Math.floor(y);

            // Check bounds
            if (gridX < 0 || gridX >= mazeWidth || gridY < 0 || gridY >= mazeHeight) {
                return false;
            }

            // Check if the cell exists and is not a wall
            if (!maze[gridY] || !maze[gridY][gridX]) {
                return false;
            }

            return !maze[gridY][gridX].wall;
        }        function checkWin() {
            const gridX = Math.floor(playerX);
            const gridY = Math.floor(playerY);

            if (gridX === goalX && gridY === goalY) {
                gameWon = true;
                const timeElapsed = Math.floor((Date.now() - startTime) / 1000);
                showMessage(`🎉 Congratulations! You reached the goal in ${steps} steps and ${timeElapsed} seconds!`, "victory");
            }
        }

        function updateDisplay() {
            const gridX = Math.floor(playerX);
            const gridY = Math.floor(playerY);
            document.getElementById('direction-text').textContent = directionNames[playerDir];
            document.getElementById('compass-arrow').textContent = directionArrows[playerDir];
        }

        function updateStats() {
            document.getElementById('steps').textContent = steps;

            const timeElapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(timeElapsed / 60);
            const seconds = timeElapsed % 60;
            document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function showMessage(text, type = "") {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = type;
        }

        // 3D Rendering
        function render3D() {
            // Clear canvas with gradient sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT / 2);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

            // Draw floor with perspective
            const floorGradient = ctx.createLinearGradient(0, SCREEN_HEIGHT / 2, 0, SCREEN_HEIGHT);
            floorGradient.addColorStop(0, '#8B7355');
            floorGradient.addColorStop(1, '#654321');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

            // Cast rays for 3D view (higher resolution)
            const rayCount = Math.floor(SCREEN_WIDTH / 2); // Reduce ray count for performance
            for (let i = 0; i < rayCount; i++) {
                const rayAngle = (i / rayCount - 0.5) * FOV;
                castRay(i * 2, rayAngle); // Scale up for full width
            }

            // Render the goal cube if it's in an open space and visible
            renderGoalCube();

            // Draw goal indicator if visible
            drawGoalIndicator();

            // Draw minimap - show player position and nearby maze structure
            drawMinimap();
        }

        function castRay(screenX, rayAngle) {
            const [dirX, dirY] = directions[playerDir];

            // Calculate ray direction with proper rotation
            const cos = Math.cos(rayAngle);
            const sin = Math.sin(rayAngle);
            let rayDirX = dirX * cos - dirY * sin;
            let rayDirY = dirX * sin + dirY * cos;

            // Ensure we have valid ray direction
            if (Math.abs(rayDirX) < 0.0001) rayDirX = 0.0001;
            if (Math.abs(rayDirY) < 0.0001) rayDirY = 0.0001;

            // Position the camera/eye point slightly back from the player center
            // This gives better perspective when close to walls
            const eyeOffsetDistance = 0.3;
            let rayX = playerX - dirX * eyeOffsetDistance;
            let rayY = playerY - dirY * eyeOffsetDistance;

            // Length of ray from current position to x or y side
            const deltaDistX = Math.abs(1 / rayDirX);
            const deltaDistY = Math.abs(1 / rayDirY);

            let hit = false;
            let side; // 0 for North/South wall, 1 for East/West wall

            // Calculate step and initial sideDist
            let stepX, stepY;
            let sideDistX, sideDistY;
            let mapX = Math.floor(rayX);
            let mapY = Math.floor(rayY);

            if (rayDirX < 0) {
                stepX = -1;
                sideDistX = (rayX - mapX) * deltaDistX;
            } else {
                stepX = 1;
                sideDistX = (mapX + 1.0 - rayX) * deltaDistX;
            }

            if (rayDirY < 0) {
                stepY = -1;
                sideDistY = (rayY - mapY) * deltaDistY;
            } else {
                stepY = 1;
                sideDistY = (mapY + 1.0 - rayY) * deltaDistY;
            }

            // Perform DDA
            while (!hit) {

                // Jump to next map square, either in x-direction, or in y-direction
                if (sideDistX < sideDistY) {
                    sideDistX += deltaDistX;
                    mapX += stepX;
                    side = 0;
                } else {
                    sideDistY += deltaDistY;
                    mapY += stepY;
                    side = 1;
                }

                // Check if ray has hit a wall
                if (mapX < 0 || mapX >= mazeWidth || mapY < 0 || mapY >= mazeHeight) {
                    hit = true; // Hit boundary
                } else if (maze[mapY] && maze[mapY][mapX] && maze[mapY][mapX].wall) {
                    hit = true; // Hit wall
                }
            }

            // Calculate distance projected on camera direction
            let perpWallDist;
            if (side == 0) {
                perpWallDist = (mapX - rayX + (1 - stepX) / 2) / rayDirX;
            } else {
                perpWallDist = (mapY - rayY + (1 - stepY) / 2) / rayDirY;
            }

            // Calculate height of line to draw on screen with modified perspective
            // Use a dampened distance calculation to make close walls less dominant
            const adjustedDist = Math.max(perpWallDist, 0.3) + (perpWallDist * 0.5);
            let lineHeight = Math.floor(SCREEN_HEIGHT / adjustedDist);

            // Cap maximum wall height to maintain perspective depth
            const maxWallHeight = SCREEN_HEIGHT * 0.85;
            lineHeight = Math.min(lineHeight, maxWallHeight);

            // Calculate lowest and highest pixel to fill in current stripe
            let drawStart = Math.floor(-lineHeight / 2 + SCREEN_HEIGHT / 2);
            if (drawStart < 0) drawStart = 0;

            let drawEnd = Math.floor(lineHeight / 2 + SCREEN_HEIGHT / 2);
            if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

            // Choose wall color based on side and add distance-based shading
            let baseColor;
            if (mapX < 0 || mapX >= mazeWidth || mapY < 0 || mapY >= mazeHeight) {
                // Boundary walls - darker
                baseColor = side == 1 ? 60 : 40;
            } else if (mapX === goalX && mapY === goalY) {
                // Goal cell - green
                baseColor = side == 1 ? 120 : 100;
            } else {
                // Regular walls
                baseColor = side == 1 ? 180 : 120;
            }

            // Apply distance fog
            const fogFactor = Math.max(0.2, 1 - perpWallDist * 0.1);
            const finalColor = Math.floor(baseColor * fogFactor);

            // Draw the wall column with proper shading
            let wallColor;
            if (mapX === goalX && mapY === goalY) {
                // Goal wall is green
                wallColor = `rgb(${Math.floor(finalColor * 0.3)}, ${finalColor}, ${Math.floor(finalColor * 0.3)})`;
            } else {
                // Regular walls are gray/brown
                wallColor = `rgb(${finalColor}, ${Math.floor(finalColor * 0.9)}, ${Math.floor(finalColor * 0.7)})`;
            }

            // Draw wall column
            ctx.fillStyle = wallColor;
            ctx.fillRect(screenX, drawStart, 2, drawEnd - drawStart + 1);

            // Add wall texture lines for more detail
            if (perpWallDist < 4) {
                ctx.strokeStyle = `rgba(0,0,0,${0.3 * fogFactor})`;
                ctx.lineWidth = 1;
                ctx.beginPath();

                // Vertical texture lines
                if (side === 1) {
                    const wallX = rayY + perpWallDist * rayDirY;
                    const texX = Math.floor((wallX - Math.floor(wallX)) * 8);
                    if (texX % 2 === 0) {
                        ctx.moveTo(screenX + 1, drawStart);
                        ctx.lineTo(screenX + 1, drawEnd);
                    }
                } else {
                    const wallY = rayX + perpWallDist * rayDirX;
                    const texY = Math.floor((wallY - Math.floor(wallY)) * 8);
                    if (texY % 2 === 0) {
                        ctx.moveTo(screenX + 1, drawStart);
                        ctx.lineTo(screenX + 1, drawEnd);
                    }
                }
                ctx.stroke();
            }
        }

        function renderCloseWall(screenX) {
            // Render a very close wall (player is in a wall)
            const drawStart = 0;
            const drawEnd = SCREEN_HEIGHT - 1;

            ctx.fillStyle = 'rgb(50, 45, 35)'; // Dark wall color
            ctx.fillRect(screenX, drawStart, 2, drawEnd - drawStart + 1);
        }

        function renderDistantWall(screenX) {
            // Render a distant boundary wall as fallback
            const lineHeight = 100; // Small wall in distance
            const drawStart = Math.floor((SCREEN_HEIGHT - lineHeight) / 2);
            const drawEnd = Math.floor((SCREEN_HEIGHT + lineHeight) / 2);

            ctx.fillStyle = 'rgb(80, 72, 56)'; // Medium wall color
            ctx.fillRect(screenX, drawStart, 2, drawEnd - drawStart + 1);
        }

        function hasLineOfSight(fromX, fromY, toX, toY) {
            // Use a simple line-of-sight algorithm (similar to ray casting)
            const dx = toX - fromX;
            const dy = toY - fromY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Check points along the line from player to goal
            const steps = Math.ceil(distance * 2); // Check every 0.5 units

            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                const checkX = fromX + dx * t;
                const checkY = fromY + dy * t;

                // Convert to grid coordinates
                const gridX = Math.floor(checkX);
                const gridY = Math.floor(checkY);

                // Check if this point is in a wall
                if (gridX >= 0 && gridX < mazeWidth &&
                    gridY >= 0 && gridY < mazeHeight &&
                    maze[gridY] && maze[gridY][gridX] &&
                    maze[gridY][gridX].wall) {
                    return false; // Line of sight blocked
                }
            }

            return true; // Clear line of sight
        }

        function renderGoalCube() {
            // Check if goal is in an open space (not a wall)
            if (maze[goalY] && maze[goalY][goalX] && maze[goalY][goalX].wall) {
                console.log(`Goal at (${goalX}, ${goalY}) is in a wall! This should not happen.`);
                return; // Don't render cube if goal is in a wall
            }

            // Additional check: make sure goal cell exists and is properly set
            if (!maze[goalY] || !maze[goalY][goalX]) {
                console.log(`Goal cell at (${goalX}, ${goalY}) does not exist in maze!`);
                return;
            }

            // Calculate goal position relative to player
            const goalCenterX = goalX + 0.5;
            const goalCenterY = goalY + 0.5;
            const dx = goalCenterX - playerX;
            const dy = goalCenterY - playerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Only render if goal is reasonably close (within view distance)
            if (distance > MAX_DEPTH) return;

            // Calculate if goal is in field of view
            const [dirX, dirY] = directions[playerDir];

            // Transform goal position to camera space
            const relativeX = dx * dirX + dy * dirY;  // Forward distance
            const relativeY = -dx * dirY + dy * dirX; // Side distance

            // Check if goal is in front of player
            if (relativeX <= 0.1) return;

            // Check line of sight - make sure no walls block the view to the goal
            if (!hasLineOfSight(playerX, playerY, goalCenterX, goalCenterY)) {
                return; // Don't render cube if it's blocked by walls
            }

            // Calculate screen position
            const screenX = (SCREEN_WIDTH / 2) + (relativeY / relativeX) * (SCREEN_WIDTH / 2) / Math.tan(FOV / 2);

            // Check if within screen bounds
            if (screenX < -50 || screenX > SCREEN_WIDTH + 50) return;

            // Calculate animated cube size and position
            const time = Date.now() * 0.003; // Animation timer
            const baseCubeSize = Math.max(20, 70 / relativeX);

            // Floating animation - gentle bounce up and down
            const bounceHeight = Math.sin(time * 1.5) * 6;

            // Rotation animation - slow spin
            const rotationAngle = time * 0.5; // Slow rotation

            // Scale pulse effect - subtle breathing
            const pulseScale = 1 + Math.sin(time * 2) * 0.05;
            const cubeSize = baseCubeSize * pulseScale;
            const cubeHeight = cubeSize * 1.0;

            // Calculate vertical position (floating above floor)
            const floorLevel = SCREEN_HEIGHT / 2;
            const hoverHeight = 15; // Base hover height
            const cubeBottom = floorLevel - hoverHeight + bounceHeight;
            const cubeTop = cubeBottom - cubeHeight;

            // Apply distance fog
            const fogFactor = Math.max(0.3, 1 - relativeX * 0.15);

            // Bright golden colors that shimmer
            const shimmer = 0.8 + Math.sin(time * 3) * 0.2;
            const baseRed = Math.floor(255 * fogFactor * shimmer);
            const baseGreen = Math.floor(215 * fogFactor * shimmer);
            const baseBlue = Math.floor(0 * fogFactor);

            // Add glowing aura
            if (distance < 4) {
                ctx.save();
                ctx.globalAlpha = 0.3 + Math.sin(time * 2) * 0.2;
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = cubeSize * 0.6;
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(screenX - cubeSize*0.6, cubeTop - cubeSize*0.3, cubeSize*1.2, cubeHeight + cubeSize*0.6);
                ctx.restore();
            }

            // Apply rotation transformation
            ctx.save();
            ctx.translate(screenX, cubeTop + cubeHeight/2);
            ctx.rotate(rotationAngle);

            // Main cube face with gradient
            const gradient = ctx.createLinearGradient(-cubeSize/2, -cubeHeight/2, cubeSize/2, cubeHeight/2);
            gradient.addColorStop(0, `rgb(${baseRed}, ${baseGreen}, ${baseBlue})`);
            gradient.addColorStop(0.5, `rgb(${Math.floor(baseRed * 1.2)}, ${Math.floor(baseGreen * 1.2)}, ${baseBlue})`);
            gradient.addColorStop(1, `rgb(${Math.floor(baseRed * 0.7)}, ${Math.floor(baseGreen * 0.7)}, ${baseBlue})`);

            ctx.fillStyle = gradient;
            ctx.fillRect(-cubeSize/2, -cubeHeight/2, cubeSize, cubeHeight);

            // 3D top face
            const topBrightness = 1.4;
            ctx.fillStyle = `rgb(${Math.min(255, baseRed * topBrightness)}, ${Math.min(255, baseGreen * topBrightness)}, ${Math.floor(baseBlue * topBrightness)})`;
            ctx.beginPath();
            ctx.moveTo(-cubeSize/2, -cubeHeight/2);
            ctx.lineTo(-cubeSize/2 + cubeSize/4, -cubeHeight/2 - cubeSize/4);
            ctx.lineTo(cubeSize/2 + cubeSize/4, -cubeHeight/2 - cubeSize/4);
            ctx.lineTo(cubeSize/2, -cubeHeight/2);
            ctx.fill();

            // 3D right face
            const sideDarkness = 0.6;
            ctx.fillStyle = `rgb(${Math.floor(baseRed * sideDarkness)}, ${Math.floor(baseGreen * sideDarkness)}, ${Math.floor(baseBlue * sideDarkness)})`;
            ctx.beginPath();
            ctx.moveTo(cubeSize/2, -cubeHeight/2);
            ctx.lineTo(cubeSize/2 + cubeSize/4, -cubeHeight/2 - cubeSize/4);
            ctx.lineTo(cubeSize/2 + cubeSize/4, cubeHeight/2 - cubeSize/4);
            ctx.lineTo(cubeSize/2, cubeHeight/2);
            ctx.fill();

            // Clean outline for definition
            ctx.strokeStyle = `rgba(180, 140, 0, ${0.8 * fogFactor})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(-cubeSize/2, -cubeHeight/2, cubeSize, cubeHeight);

            ctx.restore();

            // Add subtle sparkle effects around the cube
            for (let i = 0; i < 4; i++) {
                const sparkleTime = time + i * Math.PI * 0.5;
                const sparkleX = screenX + Math.cos(sparkleTime) * cubeSize * 0.8;
                const sparkleY = cubeTop + cubeHeight/2 + Math.sin(sparkleTime * 0.7) * cubeHeight * 0.4;
                const sparkleAlpha = Math.max(0, Math.sin(sparkleTime * 2)) * fogFactor;

                if (sparkleAlpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = sparkleAlpha;
                    ctx.fillStyle = '#FFFF80';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Add reaching indicator when very close
            if (distance < 2) {
                ctx.save();
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.sin(time * 3) * 0.4 + 0.6})`;
                ctx.textAlign = 'center';
                ctx.fillText('✨ REACH! ✨', screenX, cubeTop - 25);
                ctx.restore();
            }
        }

        function drawGoalIndicator() {
            // Calculate if goal is visible and draw indicators
            const goalDx = goalX + 0.5 - playerX; // Center of goal cell
            const goalDy = goalY + 0.5 - playerY; // Center of goal cell
            const distance = Math.sqrt(goalDx * goalDx + goalDy * goalDy);

            // Show distance to goal
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`Goal: ${Math.floor(distance)} cells away`, SCREEN_WIDTH - 10, 30);

            if (distance < 4) { // Show directional indicator when close
                const [dirX, dirY] = directions[playerDir];
                const dot = goalDx * dirX + goalDy * dirY;

                if (dot > 0.5) { // Goal is in front
                    ctx.fillStyle = '#00FF00';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('🎯 GOAL AHEAD 🎯', SCREEN_WIDTH / 2, 60);
                }
            }

            // Add crosshair in center
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            const centerX = SCREEN_WIDTH / 2;
            const centerY = SCREEN_HEIGHT / 2;

            ctx.beginPath();
            ctx.moveTo(centerX - 10, centerY);
            ctx.lineTo(centerX + 10, centerY);
            ctx.moveTo(centerX, centerY - 10);
            ctx.lineTo(centerX, centerY + 10);
            ctx.stroke();
        }

        // Draw a mini-map overlay showing player position and surrounding cells
        function drawMinimap() {
            const mapSize = 70;
            const cellSize = 10;
            const mapX = 10;
            const mapY = SCREEN_HEIGHT - mapSize - 10;

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(mapX, mapY, mapSize, mapSize);

            // Draw surrounding maze cells (5x5 around player)
            const centerX = Math.floor(playerX);
            const centerY = Math.floor(playerY);

            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const checkX = centerX + dx;
                    const checkY = centerY + dy;

                    if (maze[checkY] && maze[checkY][checkX]) {
                        const pixelX = mapX + (dx + 2) * cellSize + 10;
                        const pixelY = mapY + (dy + 2) * cellSize + 10;

                        if (maze[checkY][checkX].wall) {
                            ctx.fillStyle = '#666'; // Wall
                        } else {
                            ctx.fillStyle = '#FFF'; // Open path
                        }

                        ctx.fillRect(pixelX, pixelY, cellSize, cellSize);
                    }
                }
            }

            // Draw player position (red dot)
            const playerPixelX = mapX + 2 * cellSize + (playerX - centerX) * cellSize + 10;
            const playerPixelY = mapY + 2 * cellSize + (playerY - centerY) * cellSize + 10;

            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(playerPixelX, playerPixelY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw player direction
            const [dirX, dirY] = directions[playerDir];
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playerPixelX, playerPixelY);
            ctx.lineTo(playerPixelX + dirX * 8, playerPixelY + dirY * 8);
            ctx.stroke();

            // Debug text
            ctx.fillStyle = '#FFF';
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';

            const currentCell = maze[Math.floor(playerY)] && maze[Math.floor(playerY)][Math.floor(playerX)];

            // Show if player is properly centered
            const isXCentered = Math.abs(playerX - Math.floor(playerX) - 0.5) < 0.01;
            const isYCentered = Math.abs(playerY - Math.floor(playerY) - 0.5) < 0.01;
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    moveForward();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    moveBackward();
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    turnLeft();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    turnRight();
                    break;
            }
        });

        // Initialize game when page loads
        init();
    </script>
</body>
</html>
