<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Life Duel – Kid‑Friendly Edition (Animated)</title>
<style>
body{font-family:sans-serif;margin:0;padding:0;display:flex;justify-content:center;align-items:flex-start;margin-top:10px}
#container{display:flex;justify-content:center;align-items:flex-start}
canvas{border:1px solid #555;cursor:pointer;display:block}
.sideinfo{width:220px;font-size:0.9rem;line-height:1.4;text-align:left;padding:0 10px}
.sideinfo .player{font-weight:bold;font-size:1.1rem}
.guide{background:#f9f9f9;border:1px solid #ccc;border-radius:6px;padding:10px;font-size:0.85rem;margin-top:10px}
button,select{margin-top:6px;padding:6px 12px;font-size:0.92rem;cursor:pointer}
button:disabled{opacity:0.5;cursor:not-allowed}
</style>
</head>
<body>
<div id="container">
  <div id="leftPanel" class="sideinfo">
    <label for="boardSize">Board size:</label>
    <select id="boardSize">
      <option value="7">7 × 7</option>
      <option value="10">10 × 10</option>
      <option value="15" selected>15 × 15</option>
    </select>
    <button id="newGameBtn">New Game</button>
    <div id="stats" style="margin-top:10px"></div>
    <button id="evolveBtn" disabled style="background:#4caf50;color:#fff">Evolve!</button>
  </div>

  <canvas id="board"></canvas>

  <div id="guide" class="sideinfo guide"></div>
</div>

<script>
const boardCanvas=document.getElementById('board');
const ctx=boardCanvas.getContext('2d');
const sizeSelect=document.getElementById('boardSize');
const newGameBtn=document.getElementById('newGameBtn');
const evolveBtn=document.getElementById('evolveBtn');
const statsDiv=document.getElementById('stats');
const guideDiv=document.getElementById('guide');

guideDiv.innerHTML=`<h3>How the World Changes (Animated)</h3>
<ol style='padding-left:18px'>
<li><b>X time</b> – Squares that will disappear show an <span style='color:#000;font-weight:bold'>X</span>.</li>
<li><b>Fade</b> – X squares fade away.</li>
<li><b>O time</b> – Empty spots that get a baby show a colored <b>O</b> then grow.</li>
</ol>
<p>Press <b>Evolve!</b> after both players place 3 squares.</p>`;

let size=15, cellSize=40, maxRounds=10;
let grid, currentPlayer, placements, round, gameOver, animating, waitingEvolution;

function setBoardSize(newSize){
  size=newSize;
  cellSize=Math.floor(600/size);
  boardCanvas.width=cellSize*size;
  boardCanvas.height=cellSize*size;
}

function initGame(){
  grid=Array.from({length:size},()=>Array(size).fill(0));
  currentPlayer=1;
  placements=0;
  round=0;
  gameOver=false;
  animating=false;
  waitingEvolution=false;
  evolveBtn.disabled=true;
  draw();
}

function newGame(){
  setBoardSize(parseInt(sizeSelect.value,10));
  initGame();
}
newGameBtn.addEventListener('click',newGame);

// Conway rules
function nextGridFrom(g){
  const next=Array.from({length:size},()=>Array(size).fill(0));
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const counts=[0,0,0,0];
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          if(dx||dy){
            const nx=x+dx,ny=y+dy;
            if(nx>=0&&ny>=0&&nx<size&&ny<size) counts[g[ny][nx]]++;
          }
        }
      }
      const live=counts[1]+counts[2]+counts[3];
      const cell=g[y][x];
      if(cell!==0){
        if(live===2||live===3) next[y][x]=cell;
      } else if(live===3){
        next[y][x]=counts[1]>counts[2]?1:counts[2]>counts[1]?2:3;
      }
    }
  }
  return next;
}

let hover={x:-1,y:-1};
boardCanvas.addEventListener('mousemove',e=>{hover=eventToCell(e);draw();});
boardCanvas.addEventListener('mouseleave',()=>{hover={x:-1,y:-1};draw();});

boardCanvas.addEventListener('click',e=>{
  if(gameOver||animating||waitingEvolution) return;
  const {x,y}=eventToCell(e);
  if(x<0||y<0||x>=size||y>=size) return;
  if(grid[y][x]!==0) return;
  grid[y][x]=currentPlayer;
  placements++;
  if(placements===3){
    placements=0;
    if(currentPlayer===1){
      currentPlayer=2;
    }else{
      currentPlayer=1;
      waitingEvolution=true;
      evolveBtn.disabled=false;
    }
  }
  draw();
});

evolveBtn.addEventListener('click',()=>{if(!waitingEvolution||animating) return; evolveBtn.disabled=true; waitingEvolution=false; animateEvolution();});

function animateEvolution(){
  animating=true;
  const nextGrid=nextGridFrom(grid);
  const dying=[]; const babies=[];
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(grid[y][x]!==0 && nextGrid[y][x]===0) dying.push({x,y});
      if(grid[y][x]===0 && nextGrid[y][x]!==0) babies.push({x,y,color:nextGrid[y][x]});
    }
  }
  // Stage 1: show markers (already in draw)
  draw();
  // Stage 2: fade dying squares
  fadeOut(dying,()=>{
    // Stage 3: blink babies
    blinkBabies(babies,()=>{
      // Commit new grid
      grid=nextGrid;
      round++;
      if(round>=maxRounds) gameOver=true;
      animating=false;
      draw();
    });
  });
}

function fadeOut(cells,done){
  const steps=10, interval=50; let step=0;
  const fadeInt=setInterval(()=>{
    step++;
    ctx.save();
    ctx.globalAlpha=1-step/steps;
    cells.forEach(({x,y})=>{
      const v=grid[y][x];
      ctx.fillStyle=v===1?"#1e90ff":v===2?"#ff4d4d":"#cccccc";
      ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize);
    });
    ctx.restore();
    if(step>=steps){
      clearInterval(fadeInt);
      cells.forEach(({x,y})=>grid[y][x]=0);
      draw();
      done();
    }
  },interval);
}

function blinkBabies(cells,done){
  let visible=true, count=0; const maxBlinks=4, interval=200;
  const blinkInt=setInterval(()=>{
    visible=!visible; count++;
    draw();
    if(visible){
      cells.forEach(({x,y,color})=>{
        ctx.fillStyle=color===1?"#1e90ff":color===2?"#ff4d4d":"#888";
        ctx.font=`bold ${cellSize*0.6}px sans-serif`;
        ctx.textAlign='center';ctx.textBaseline='middle';
        ctx.fillText('O',x*cellSize+cellSize/2,y*cellSize+cellSize/2);
      });
    }
    if(count>=maxBlinks){
      clearInterval(blinkInt);
      done();
    }
  },interval);
}

function eventToCell(e){
  const rect=boardCanvas.getBoundingClientRect();
  return {x:Math.floor((e.clientX-rect.left)/cellSize), y:Math.floor((e.clientY-rect.top)/cellSize)};
}

function draw(){
  ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
  const preview=animating?null:nextGridFrom(grid);
  let blue=0,red=0;
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const v=grid[y][x];
      if(v){
        ctx.fillStyle=v===1?"#1e90ff":v===2?"#ff4d4d":"#cccccc";
        ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize);
        if(v===1)blue++; else if(v===2)red++;
      }
      ctx.strokeStyle="#888";
      ctx.strokeRect(x*cellSize,y*cellSize,cellSize,cellSize);

      if(!animating && preview){
        const next=preview[y][x];
        if(v!==0 && next===0){
          ctx.fillStyle="#000";
          ctx.font=`bold ${cellSize*0.6}px sans-serif`;
          ctx.textAlign='center';ctx.textBaseline='middle';
          ctx.fillText('X',x*cellSize+cellSize/2,y*cellSize+cellSize/2);
        }else if(v===0 && next!==0){
          ctx.fillStyle=next===1?"#1e90ff":next===2?"#ff4d4d":"#888";
          ctx.font=`bold ${cellSize*0.6}px sans-serif`;
          ctx.textAlign='center';ctx.textBaseline='middle';
          ctx.fillText('O',x*cellSize+cellSize/2,y*cellSize+cellSize/2);
        }
      }
    }
  }

  if(!gameOver && !animating && !waitingEvolution && placements<3 && hover.x>=0 && hover.y>=0 && grid[hover.y][hover.x]===0){
    ctx.globalAlpha=0.3;
    ctx.fillStyle=currentPlayer===1?"#1e90ff":"#ff4d4d";
    ctx.fillRect(hover.x*cellSize,hover.y*cellSize,cellSize,cellSize);
    ctx.globalAlpha=1.0;
  }
  updateStats(blue,red);
}

function updateStats(blue,red){
  const blueMoves=currentPlayer===1?3-placements:0;
  const redMoves=currentPlayer===2?3-placements:0;
  statsDiv.innerHTML=`<b>Round ${round+1}/${maxRounds}</b>`+
    `<br><span class='player' style='color:#1e90ff'>Blue</span> – Cells: ${blue}, Moves: ${blueMoves}`+
    `<br><span class='player' style='color:#ff4d4d'>Red</span> – Cells: ${red}, Moves: ${redMoves}`+
    `<br><br><b>${gameOver?"Game Over!":animating?"Evolving…":waitingEvolution?"Press Evolve!":"Turn: "+(currentPlayer===1?"Blue":"Red")}</b>`;
  evolveBtn.disabled=waitingEvolution?false:true; // but during animating it's disabled already
}

// initialize
newGame();
</script>
</body>
</html>