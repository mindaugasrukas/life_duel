<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Life Duel Prototype – Preview Edition</title>
<style>
body{font-family:sans-serif;text-align:center;margin:0;padding:0}
#container{display:flex;justify-content:center;align-items:center;margin-top:10px}
canvas{border:1px solid #555;cursor:pointer}
.sideinfo{width:140px;font-size:0.9rem;line-height:1.4;text-align:left;padding:0 6px}
.sideinfo span.player{font-weight:bold;font-size:1.1rem}
#guide{max-width:640px;margin:10px auto;text-align:left;background:#f9f9f9;padding:10px;border:1px solid #ccc;border-radius:6px;font-size:0.9rem}
#guide h3{margin:5px 0}
</style>
</head>
<body>
<h2>Life Duel – Preview Edition</h2>
<div id="container">
   <div id="leftInfo" class="sideinfo"></div>
   <canvas id="board" width="600" height="600"></canvas>
   <div id="rightInfo" class="sideinfo"></div>
</div>
<section id="guide">
<h3>How the World Changes (Easy Guide)</h3>
<ul>
 <li><b>Happy squares</b>: If a colored square has <b>2&nbsp;or&nbsp;3</b> colored neighbors, it stays. Otherwise it disappears and shows a <span style="color:#000;font-weight:bold">X</span>.</li>
 <li><b>Baby squares</b>: An empty spot with <b>exactly 3</b> neighbors gets a baby square. We show a tiny colored <span style="font-weight:bold">O</span> there.</li>
 <li><b>Baby color</b>: More blues ⇒ baby is <span style="color:#1e90ff;font-weight:bold">Blue</span>. More reds ⇒ baby is <span style="color:#ff4d4d;font-weight:bold">Red</span>. Same ⇒ <span style="color:#888;font-weight:bold">Grey</span>.</li>
 <li>These <b>X/O</b> hints update live so you can plan.</li>
</ul>
</section>
<script>
const size=15;
const cellSize=40; // 600/15
const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
let grid=Array.from({length:size},()=>Array(size).fill(0)); //0 empty,1 blue,2 red,3 grey
let currentPlayer=1; //1 blue, 2 red
let placements=0;
let round=0;
const maxRounds=10;
let hover={x:-1,y:-1};

const leftDiv=document.getElementById('leftInfo');
const rightDiv=document.getElementById('rightInfo');

function computeNextGrid(){
 let next=Array.from({length:size},()=>Array(size).fill(0));
 for(let y=0;y<size;y++){
  for(let x=0;x<size;x++){
   let counts=[0,0,0,0];
   for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
     if(dx===0&&dy===0)continue;
     let nx=x+dx, ny=y+dy;
     if(nx>=0&&ny>=0&&nx<size&&ny<size){counts[ grid[ny][nx] ]++;}
    }
   }
   let live=counts[1]+counts[2]+counts[3];
   let cell=grid[y][x];
   if(cell!==0){
     if(live===2||live===3) next[y][x]=cell; //survive
   } else {
     if(live===3){
        if(counts[1]>counts[2]) next[y][x]=1;
        else if(counts[2]>counts[1]) next[y][x]=2;
        else next[y][x]=3;
     }
   }
  }
 }
 return next;
}

function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 const preview=computeNextGrid();
 for(let y=0;y<size;y++){
  for(let x=0;x<size;x++){
   let v=grid[y][x];
   if(v){
     ctx.fillStyle=v===1?"#1e90ff":v===2?"#ff4d4d":"#cccccc";
     ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize);
   }
   ctx.strokeStyle="#888";
   ctx.strokeRect(x*cellSize,y*cellSize,cellSize,cellSize);

   // preview markers
   let next=preview[y][x];
   if(v!==0){ //currently alive
     if(next===0){ //dies
       ctx.fillStyle="#000";
       ctx.font="bold 24px sans-serif";
       ctx.textAlign="center";ctx.textBaseline="middle";
       ctx.fillText("X", x*cellSize+cellSize/2, y*cellSize+cellSize/2);
     }
   } else { //currently empty
     if(next!==0){ //will be born
       ctx.fillStyle=next===1?"#1e90ff":next===2?"#ff4d4d":"#888";
       ctx.font="bold 24px sans-serif";
       ctx.textAlign="center";ctx.textBaseline="middle";
       ctx.fillText("O", x*cellSize+cellSize/2, y*cellSize+cellSize/2);
     }
   }
  }
 }

 // hover highlight
 if(hover.x>=0&&hover.y>=0&&round<maxRounds&&placements<3){
   if(grid[hover.y][hover.x]===0){
     ctx.globalAlpha=0.3;
     ctx.fillStyle=currentPlayer===1?"#1e90ff":"#ff4d4d";
     ctx.fillRect(hover.x*cellSize,hover.y*cellSize,cellSize,cellSize);
     ctx.globalAlpha=1.0;
   }
 }
 updateSideInfo();
}

function updateSideInfo(){
 let blueMoves=currentPlayer===1?3-placements:0;
 let redMoves=currentPlayer===2?3-placements:0;
 leftDiv.innerHTML=`<span class='player' style='color:#1e90ff'>Blue</span><br>Moves left: ${blueMoves}`;
 rightDiv.innerHTML=`Round ${round+1}/${maxRounds}<br><span class='player' style='color:#ff4d4d'>Red</span><br>Moves left: ${redMoves}<br><br><b>${currentPlayer===1?'Blue':'Red'}'s turn</b><br>Place square ${placements+1}/3`;
}

canvas.addEventListener("click",e=>{
 if(round>=maxRounds)return;
 const {x,y}=eventToCell(e);
 if(x<0||x>=size||y<0||y>=size)return;
 if(grid[y][x]!==0)return; //occupied
 grid[y][x]=currentPlayer;
 placements++;
 if(placements>=3){
  placements=0;
  if(currentPlayer===1){
    currentPlayer=2;
    draw();
    return;
  } else {
    currentPlayer=1;
    grid=computeNextGrid(); //apply evolution
    round++;
    if(round>=maxRounds){endGame();return;}
  }
 }
 draw();
});

canvas.addEventListener("mousemove",e=>{
 const {x,y}=eventToCell(e);
 if(x!==hover.x||y!==hover.y){hover={x,y};draw();}
});

canvas.addEventListener("mouseleave",()=>{hover={x:-1,y:-1};draw();});

function eventToCell(e){
 const rect=canvas.getBoundingClientRect();
 const x=Math.floor((e.clientX-rect.left)/cellSize);
 const y=Math.floor((e.clientY-rect.top)/cellSize);
 return {x,y};
}

function endGame(){
 let blue=0,red=0;
 for(let y=0;y<size;y++){
  for(let x=0;x<size;x++){
   if(grid[y][x]===1)blue++;
   else if(grid[y][x]===2)red++;
  }
 }
 rightDiv.innerHTML=`<b>Game Over</b><br>Blue: ${blue}<br>Red: ${red}<br><br>${blue===red?"It's a tie!":blue>red?"Blue wins!":"Red wins!"}`;
 leftDiv.innerHTML="";
 draw();
}

draw();
</script>
</body>
</html>