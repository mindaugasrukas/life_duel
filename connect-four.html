<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Connect Four AI</title>
    <style>
        body {
            font-family: sans-serif;
            text-align: center;
        }

        #game-container {
            margin: 50px auto;
            width: fit-content;
        }

        #drop-zone {
            height: 80px;
            margin-bottom: 10px;
            position: relative;
            cursor: none;
        }

        .hover-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: red;
            border: 3px solid darkred;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            top: 10px;
        }

        .hover-piece.visible {
            opacity: 0.8;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-gap: 5px;
            position: relative;
            background: #2c5aa0;
            padding: 10px;
            border-radius: 10px;
        }

        .cell {
            width: 60px;
            height: 60px;
            background: #ddd;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            position: relative;
            overflow: visible;
        }

        .cell.filled {
            z-index: 10;
        }

        .cell.empty {
            z-index: 1;
        }

        .dropping-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
        }

        @keyframes drop {
            from {
                top: -60px;
            }
            to {
                /* Final position will be set dynamically */
            }
        }

        #message {
            font-size: 1.5em;
            margin-top: 20px;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
        }
    </style>
</head>

<body>
    <h1>Connect Four: You (ðŸ”´) vs AI (ðŸŸ¡)</h1>
    <div id="game-container">
        <div id="drop-zone">
            <div class="hover-piece" id="hoverPiece"></div>
        </div>
        <div id="board"></div>
    </div>
    <div id="message"></div>
    <button onclick="resetGame()">Restart</button>

    <script>
        const ROWS = 6, COLS = 7;
        const HUMAN = 'R'; // Red
        const AI = 'Y'; // Yellow
        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        let isPlayerTurn = true;
        const boardDiv = document.getElementById('board');
        const dropZoneDiv = document.getElementById('drop-zone');
        const hoverPiece = document.getElementById('hoverPiece');
        const messageDiv = document.getElementById('message');

        function createBoard() {
            // Create board cells
            boardDiv.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    if (board[r][c] === 'R') {
                        cell.style.background = 'red';
                        cell.classList.add('filled');
                    } else if (board[r][c] === 'Y') {
                        cell.style.background = 'yellow';
                        cell.classList.add('filled');
                    } else {
                        cell.style.background = '#ddd';
                        cell.classList.add('empty');
                    }

                    boardDiv.appendChild(cell);
                }
            }

            setupHoverEffects();
        }

        function setupHoverEffects() {
            // Mouse move tracking
            dropZoneDiv.addEventListener('mousemove', (e) => {
                if (!isPlayerTurn) return;

                const rect = dropZoneDiv.getBoundingClientRect();
                const boardRect = boardDiv.getBoundingClientRect();
                const x = e.clientX - rect.left;

                // Calculate which column the mouse is over
                const col = Math.floor((x - (boardRect.left - rect.left + 10)) / 65);

                if (col >= 0 && col < COLS && !board[0][col]) {
                    // Position the hover piece
                    const pieceX = (boardRect.left - rect.left + 10) + col * 65;
                    hoverPiece.style.left = pieceX + 'px';
                    hoverPiece.classList.add('visible');
                } else {
                    hoverPiece.classList.remove('visible');
                }
            });

            // Mouse leave
            dropZoneDiv.addEventListener('mouseleave', () => {
                hoverPiece.classList.remove('visible');
            });

            // Click to drop
            dropZoneDiv.addEventListener('click', (e) => {
                if (!isPlayerTurn) return;

                const rect = dropZoneDiv.getBoundingClientRect();
                const boardRect = boardDiv.getBoundingClientRect();
                const x = e.clientX - rect.left;

                // Calculate which column was clicked
                const col = Math.floor((x - (boardRect.left - rect.left + 10)) / 65);

                if (col >= 0 && col < COLS && !board[0][col]) {
                    humanMove(col);
                }
            });
        }

        function humanMove(col) {
            // Check if column is full
            if (board[0][col]) {
                return; // Column is full
            }

            if (dropPiece(col, HUMAN)) {
                isPlayerTurn = false;
                hoverPiece.classList.remove('visible');

                setTimeout(() => {
                    if (checkWinner(board, HUMAN)) return endGame("You win!");
                    if (isFull()) return endGame("It's a tie!");
                    setTimeout(aiMove, 200);
                }, 800); // Wait for animation to complete
            }
        }

        function aiMove() {
            const [score, col] = minimax(board, 10, -Infinity, +Infinity, true);
            dropPiece(col, AI);
            setTimeout(() => {
                if (checkWinner(board, AI)) return endGame("AI wins!");
                if (isFull()) return endGame("It's a tie!");

                isPlayerTurn = true;
            }, 800); // Wait for animation to complete
        }

        function dropPiece(col, player) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (!board[r][col]) {
                    board[r][col] = player;
                    animateDrop(r, col, player);
                    return true;
                }
            }
            return false;
        }

        function animateDrop(targetRow, col, player) {
            // Create the dropping piece
            const droppingPiece = document.createElement('div');
            droppingPiece.className = 'dropping-piece';
            droppingPiece.style.background = player === 'R' ? 'red' : 'yellow';

            // Position it at the top of the correct column (accounting for board padding)
            const colPosition = 10 + col * 65; // 10px board padding + col * (60px cell + 5px gap)
            droppingPiece.style.left = colPosition + 'px';
            droppingPiece.style.top = '-60px';

            // Calculate the final position (accounting for board padding)
            const finalPosition = 10 + targetRow * 65; // 10px board padding + row * (60px cell + 5px gap)

            // Add to the board container (not individual cell)
            boardDiv.appendChild(droppingPiece);

            // Create and apply the animation
            const animationDuration = Math.sqrt(targetRow + 1) * 0.2 + 0.3;

            // Create a unique keyframe for this drop
            const animationName = `drop-${Date.now()}`;
            const keyframes = `
                @keyframes ${animationName} {
                    from { top: -60px; }
                    to { top: ${finalPosition}px; }
                }
            `;

            // Add the keyframes to the document
            const style = document.createElement('style');
            style.textContent = keyframes;
            document.head.appendChild(style);

            // Apply the animation
            droppingPiece.style.animation = `${animationName} ${animationDuration}s ease-in forwards`;            // Update the target cell and clean up after animation
            setTimeout(() => {
                const targetCell = boardDiv.children[targetRow * COLS + col];
                if (targetCell && targetCell.classList.contains('cell')) {
                    targetCell.style.background = player === 'R' ? 'red' : 'yellow';
                    targetCell.classList.remove('empty');
                    targetCell.classList.add('filled');
                }

                // Remove the dropping piece and style
                if (boardDiv.contains(droppingPiece)) {
                    boardDiv.removeChild(droppingPiece);
                }
                document.head.removeChild(style);
            }, animationDuration * 1000);
        }

        function isFull() {
            return board[0].every(cell => cell);
        }

        function checkWinner(b, p) {
            // Horizontal, Vertical, Diagonal checks
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++)
                    if (b[r][c] === p && b[r][c + 1] === p && b[r][c + 2] === p && b[r][c + 3] === p) return true;
            }
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS; c++)
                    if (b[r][c] === p && b[r + 1][c] === p && b[r + 2][c] === p && b[r + 3][c] === p) return true;
            }
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS - 3; c++)
                    if (b[r][c] === p && b[r + 1][c + 1] === p && b[r + 2][c + 2] === p && b[r + 3][c + 3] === p) return true;
            }
            for (let r = 3; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++)
                    if (b[r][c] === p && b[r - 1][c + 1] === p && b[r - 2][c + 2] === p && b[r - 3][c + 3] === p) return true;
            }
            return false;
        }

        function minimax(b, depth, alpha, beta, maximizing) {
            if (checkWinner(b, AI)) return [1000, null];
            if (checkWinner(b, HUMAN)) return [-1000, null];
            if (isFull() || depth === 0) return [scorePosition(b), null];

            if (maximizing) {
                let maxEval = -Infinity, bestCol = null;
                for (let c = 0; c < COLS; c++) {
                    let r = getNextOpenRow(b, c);
                    if (r !== -1) {
                        const temp = b.map(row => [...row]);
                        temp[r][c] = AI;
                        let [evalScore] = minimax(temp, depth - 1, alpha, beta, false);
                        if (evalScore > maxEval) {
                            maxEval = evalScore;
                            bestCol = c;
                        }
                        alpha = Math.max(alpha, evalScore);
                        if (beta <= alpha) break;
                    }
                }
                return [maxEval, bestCol];
            } else {
                let minEval = +Infinity, bestCol = null;
                for (let c = 0; c < COLS; c++) {
                    let r = getNextOpenRow(b, c);
                    if (r !== -1) {
                        const temp = b.map(row => [...row]);
                        temp[r][c] = HUMAN;
                        let [evalScore] = minimax(temp, depth - 1, alpha, beta, true);
                        if (evalScore < minEval) {
                            minEval = evalScore;
                            bestCol = c;
                        }
                        beta = Math.min(beta, evalScore);
                        if (beta <= alpha) break;
                    }
                }
                return [minEval, bestCol];
            }
        }

        function getNextOpenRow(b, c) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (!b[r][c]) return r;
            }
            return -1;
        }

        function scorePosition(b) {
            let score = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (b[r][c] === AI) score += 1;
                    else if (b[r][c] === HUMAN) score -= 1;
                }
            }
            return score;
        }

        function endGame(msg) {
            messageDiv.textContent = msg;
            isPlayerTurn = false;
            hoverPiece.classList.remove('visible');
        }

        function resetGame() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
            messageDiv.textContent = '';
            isPlayerTurn = true;
            createBoard();
        }

        createBoard();
    </script>
</body>

</html>