<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Connect Four: You (ðŸ”´) vs AI (ðŸŸ¡)</title>
    <style>
        .dropping-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            z-index: 1;
            pointer-events: none;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .dropping-piece.red {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .dropping-piece.yellow {
            background: linear-gradient(135deg, #ffdd44, #ccaa00);
        }
        body {
            font-family: sans-serif;
            text-align: center;
        }

        #game-container {
            margin: 50px auto;
            width: fit-content;
        }

        #drop-zone {
            height: 80px;
            margin-bottom: 10px;
            position: relative;
            cursor: none;
        }

        .hover-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            top: 10px;
        }

        .hover-piece.visible {
            opacity: 0.8;
        }

        .hover-piece.red {
            background: linear-gradient(135deg, #ff4444, #cc0000) !important;
        }

        .hover-piece.yellow {
            background: linear-gradient(135deg, #ffdd44, #ccaa00) !important;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-gap: 5px;
            position: relative;
            padding: 10px;
            border-radius: 10px;
            z-index: 10;
        }

        /* Create the board frame with holes */
        #board::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #2c5aa0;
            border-radius: 10px;
            z-index: 2;
            /* Create holes using mask */
            mask:
                radial-gradient(circle at 40px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 105px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 170px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 235px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 300px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 365px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 430px 40px, transparent 28px, black 30px),
                radial-gradient(circle at 40px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 105px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 170px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 235px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 300px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 365px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 430px 105px, transparent 28px, black 30px),
                radial-gradient(circle at 40px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 105px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 170px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 235px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 300px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 365px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 430px 170px, transparent 28px, black 30px),
                radial-gradient(circle at 40px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 105px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 170px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 235px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 300px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 365px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 430px 235px, transparent 28px, black 30px),
                radial-gradient(circle at 40px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 105px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 170px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 235px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 300px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 365px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 430px 300px, transparent 28px, black 30px),
                radial-gradient(circle at 40px 365px, transparent 28px, black 30px),
                radial-gradient(circle at 105px 365px, transparent 28px, black 30px),
                radial-gradient(circle at 170px 365px, transparent 28px, black 30px),
                radial-gradient(circle at 235px 365px, transparent 28px, black 30px),
                radial-gradient(circle at 300px 365px, transparent 28px, black 30px),
                radial-gradient(circle at 365px 365px, transparent 28px, black 30px),
                radial-gradient(circle at 430px 365px, transparent 28px, black 30px);
            mask-composite: intersect;
        }

        .board-hole {
            width: 60px;
            height: 60px;
            position: relative;
            z-index: 1;
        }

        .piece {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            top: 0;
            left: 0;
            z-index: 5;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .piece.red {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .piece.yellow {
            background: linear-gradient(135deg, #ffdd44, #ccaa00);
        }

        @keyframes drop {
            from {
                top: -60px;
            }
            to {
                /* Final position will be set dynamically */
            }
        }

        #message {
            font-size: 1.5em;
            margin-top: 20px;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
        }
    </style>
</head>

<body>
    <h1>Connect Four: You (ðŸ”´) vs AI (ðŸŸ¡)</h1>
    <div id="game-container">
        <div id="drop-zone">
            <div class="hover-piece" id="hoverPiece"></div>
        </div>
        <div id="board"></div>
    </div>
    <div id="message"></div>
    <button onclick="resetGame()">Restart</button>

    <script>
        const ROWS = 6, COLS = 7;
        const HUMAN = 'R'; // Red
        const AI = 'Y'; // Yellow
        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        let isPlayerTurn = true;
        const boardDiv = document.getElementById('board');
        const dropZoneDiv = document.getElementById('drop-zone');
        const hoverPiece = document.getElementById('hoverPiece');
        const messageDiv = document.getElementById('message');

        function createBoard() {
            // Create board holes
            boardDiv.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const hole = document.createElement('div');
                    hole.className = 'board-hole';
                    hole.dataset.row = r;
                    hole.dataset.col = c;

                    // Add piece if this position is filled
                    if (board[r][c] === 'R') {
                        hole.classList.add('filled');
                        const piece = document.createElement('div');
                        piece.className = 'piece red';
                        hole.appendChild(piece);
                    } else if (board[r][c] === 'Y') {
                        hole.classList.add('filled');
                        const piece = document.createElement('div');
                        piece.className = 'piece yellow';
                        hole.appendChild(piece);
                    }

                    boardDiv.appendChild(hole);
                }
            }

            setupHoverEffects();
        }

        function setupHoverEffects() {
            // Set hover piece color for current player (red for human)
            hoverPiece.className = 'hover-piece red';

            // Mouse move tracking
            dropZoneDiv.addEventListener('mousemove', (e) => {
                if (!isPlayerTurn) return;

                const rect = dropZoneDiv.getBoundingClientRect();
                const boardRect = boardDiv.getBoundingClientRect();
                const x = e.clientX - rect.left;

                // Calculate which column the mouse is over
                const col = Math.floor((x - (boardRect.left - rect.left + 10)) / 65);

                if (col >= 0 && col < COLS && !board[0][col]) {
                    // Position the hover piece
                    const pieceX = (boardRect.left - rect.left + 10) + col * 65;
                    hoverPiece.style.left = pieceX + 'px';
                    hoverPiece.classList.add('visible');
                } else {
                    hoverPiece.classList.remove('visible');
                }
            });

            // Mouse leave
            dropZoneDiv.addEventListener('mouseleave', () => {
                hoverPiece.classList.remove('visible');
            });

            // Click to drop
            dropZoneDiv.addEventListener('click', (e) => {
                if (!isPlayerTurn) return;

                const rect = dropZoneDiv.getBoundingClientRect();
                const boardRect = boardDiv.getBoundingClientRect();
                const x = e.clientX - rect.left;

                // Calculate which column was clicked
                const col = Math.floor((x - (boardRect.left - rect.left + 10)) / 65);

                if (col >= 0 && col < COLS && !board[0][col]) {
                    humanMove(col);
                }
            });
        }

        function humanMove(col) {
            // Check if column is full
            if (board[0][col]) {
                return; // Column is full
            }

            if (dropPiece(col, HUMAN)) {
                isPlayerTurn = false;
                hoverPiece.classList.remove('visible');

                setTimeout(() => {
                    if (checkWinner(board, HUMAN)) return endGame("You win!");
                    if (isFull()) return endGame("It's a tie!");
                    setTimeout(aiMove, 200);
                }, 800); // Wait for animation to complete
            }
        }

        function aiMove() {
            const [score, col] = minimax(board, 6, -Infinity, +Infinity, true);
            dropPiece(col, AI);
            setTimeout(() => {
                if (checkWinner(board, AI)) return endGame("AI wins!");
                if (isFull()) return endGame("It's a tie!");

                isPlayerTurn = true;
                // Reset hover piece color to red for player's turn
                hoverPiece.className = 'hover-piece red';
            }, 800); // Wait for animation to complete
        }

        function dropPiece(col, player) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (!board[r][col]) {
                    board[r][col] = player;
                    animateDrop(r, col, player);
                    return true;
                }
            }
            return false;
        }

        function animateDrop(targetRow, col, player) {
            // Calculate position relative to the board
            const boardRect = boardDiv.getBoundingClientRect();
            const startX = col * 65 + 10; // Column position within board
            const startY = -80; // Start above the board
            const endY = targetRow * 65 + 10; // Final position within board

            // Create the dropping piece that will animate across the entire board
            const droppingPiece = document.createElement('div');
            droppingPiece.className = `dropping-piece ${player === 'R' ? 'red' : 'yellow'}`;
            droppingPiece.style.left = startX + 'px';
            droppingPiece.style.top = startY + 'px';
            droppingPiece.style.zIndex = '1'; // Behind board frame so only visible through holes

            // Add to the board container
            boardDiv.appendChild(droppingPiece);

            // Calculate animation duration based on drop distance
            const animationDuration = Math.sqrt(targetRow + 1) * 0.2 + 0.3;

            // Create unique keyframe for this drop
            const animationName = `drop-${Date.now()}`;
            const keyframes = `
                @keyframes ${animationName} {
                    from { top: ${startY}px; }
                    to { top: ${endY}px; }
                }
            `;

            // Add keyframes to document
            const style = document.createElement('style');
            style.textContent = keyframes;
            document.head.appendChild(style);

            // Apply animation
            droppingPiece.style.animation = `${animationName} ${animationDuration}s ease-in forwards`;

            // After animation completes, remove dropping piece and add static piece
            setTimeout(() => {
                // Remove the animated piece
                boardDiv.removeChild(droppingPiece);

                // Add the static piece to the target hole
                const targetHole = boardDiv.children[targetRow * COLS + col];
                targetHole.classList.add('filled');
                const staticPiece = document.createElement('div');
                staticPiece.className = `piece ${player === 'R' ? 'red' : 'yellow'}`;
                targetHole.appendChild(staticPiece);

                // Clean up
                document.head.removeChild(style);
            }, animationDuration * 1000);
        }

        function isFull() {
            return board[0].every(cell => cell);
        }

        function checkWinner(b, p) {
            // Horizontal, Vertical, Diagonal checks
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++)
                    if (b[r][c] === p && b[r][c + 1] === p && b[r][c + 2] === p && b[r][c + 3] === p) return true;
            }
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS; c++)
                    if (b[r][c] === p && b[r + 1][c] === p && b[r + 2][c] === p && b[r + 3][c] === p) return true;
            }
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS - 3; c++)
                    if (b[r][c] === p && b[r + 1][c + 1] === p && b[r + 2][c + 2] === p && b[r + 3][c + 3] === p) return true;
            }
            for (let r = 3; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++)
                    if (b[r][c] === p && b[r - 1][c + 1] === p && b[r - 2][c + 2] === p && b[r - 3][c + 3] === p) return true;
            }
            return false;
        }

        function minimax(b, depth, alpha, beta, maximizing) {
            if (checkWinner(b, AI)) return [1000, null];
            if (checkWinner(b, HUMAN)) return [-1000, null];
            if (isFull() || depth === 0) return [scorePosition(b), null];

            if (maximizing) {
                let maxEval = -Infinity, bestCol = null;
                for (let c = 0; c < COLS; c++) {
                    let r = getNextOpenRow(b, c);
                    if (r !== -1) {
                        const temp = b.map(row => [...row]);
                        temp[r][c] = AI;
                        let [evalScore] = minimax(temp, depth - 1, alpha, beta, false);
                        if (evalScore > maxEval) {
                            maxEval = evalScore;
                            bestCol = c;
                        }
                        alpha = Math.max(alpha, evalScore);
                        if (beta <= alpha) break;
                    }
                }
                return [maxEval, bestCol];
            } else {
                let minEval = +Infinity, bestCol = null;
                for (let c = 0; c < COLS; c++) {
                    let r = getNextOpenRow(b, c);
                    if (r !== -1) {
                        const temp = b.map(row => [...row]);
                        temp[r][c] = HUMAN;
                        let [evalScore] = minimax(temp, depth - 1, alpha, beta, true);
                        if (evalScore < minEval) {
                            minEval = evalScore;
                            bestCol = c;
                        }
                        beta = Math.min(beta, evalScore);
                        if (beta <= alpha) break;
                    }
                }
                return [minEval, bestCol];
            }
        }

        function getNextOpenRow(b, c) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (!b[r][c]) return r;
            }
            return -1;
        }

        function scorePosition(b) {
            let score = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (b[r][c] === AI) score += 1;
                    else if (b[r][c] === HUMAN) score -= 1;
                }
            }
            return score;
        }

        function endGame(msg) {
            messageDiv.textContent = msg;
            isPlayerTurn = false;
            hoverPiece.classList.remove('visible');
        }

        function resetGame() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
            messageDiv.textContent = '';
            isPlayerTurn = true;
            hoverPiece.className = 'hover-piece red'; // Set to red for player
            createBoard();
        }

        createBoard();
    </script>
</body>

</html>